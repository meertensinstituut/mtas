<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasBasicParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.analysis.parser</a> &gt; <span class="el_source">MtasBasicParser.java</span></div><h1>MtasBasicParser.java</h1><pre class="source lang-java linenums">package mtas.analysis.parser;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import mtas.analysis.token.MtasToken;
import mtas.analysis.token.MtasTokenIdFactory;
import mtas.analysis.token.MtasTokenString;
import mtas.analysis.util.MtasConfigException;
import mtas.analysis.util.MtasConfiguration;
import mtas.analysis.util.MtasParserException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;
import org.apache.lucene.analysis.payloads.PayloadHelper;
import org.apache.lucene.util.BytesRef;

/**
 * The Class MtasBasicParser.
 */
public abstract class MtasBasicParser extends MtasParser {

  /** The Constant log. */
<span class="fc" id="L38">  private static final Log log = LogFactory.getLog(MtasBasicParser.class);</span>

  /** The Constant MAPPING_TYPE_REF. */
  protected static final String MAPPING_TYPE_REF = &quot;ref&quot;;

  /** The Constant MAPPING_TYPE_RELATION. */
  protected static final String MAPPING_TYPE_RELATION = &quot;relation&quot;;

  /** The Constant MAPPING_TYPE_RELATION_ANNOTATION. */
  protected static final String MAPPING_TYPE_RELATION_ANNOTATION = &quot;relationAnnotation&quot;;

  /** The Constant MAPPING_TYPE_GROUP. */
  protected static final String MAPPING_TYPE_GROUP = &quot;group&quot;;

  /** The Constant MAPPING_TYPE_GROUP_ANNOTATION. */
  protected static final String MAPPING_TYPE_GROUP_ANNOTATION = &quot;groupAnnotation&quot;;

  /** The Constant MAPPING_TYPE_WORD. */
  protected static final String MAPPING_TYPE_WORD = &quot;word&quot;;

  /** The Constant MAPPING_TYPE_WORD_ANNOTATION. */
  protected static final String MAPPING_TYPE_WORD_ANNOTATION = &quot;wordAnnotation&quot;;

  /** The Constant ITEM_TYPE_STRING. */
  protected static final String ITEM_TYPE_STRING = &quot;string&quot;;

  /** The Constant ITEM_TYPE_NAME. */
  protected static final String ITEM_TYPE_NAME = &quot;name&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR = &quot;ancestorName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_GROUP. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_GROUP = &quot;ancestorGroupName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_GROUP_ANNOTATION. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_GROUP_ANNOTATION = &quot;ancestorGroupAnnotationName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_WORD. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_WORD = &quot;ancestorWordName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_WORD_ANNOTATION. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_WORD_ANNOTATION = &quot;ancestorWordAnnotationName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_RELATION. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_RELATION = &quot;ancestorRelationName&quot;;

  /** The Constant ITEM_TYPE_NAME_ANCESTOR_RELATION_ANNOTATION. */
  protected static final String ITEM_TYPE_NAME_ANCESTOR_RELATION_ANNOTATION = &quot;ancestorRelationAnnotationName&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE. */
  protected static final String ITEM_TYPE_ATTRIBUTE = &quot;attribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR = &quot;ancestorAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP = &quot;ancestorGroupAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP_ANNOTATION. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP_ANNOTATION = &quot;ancestorGroupAnnotationAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD = &quot;ancestorWordAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD_ANNOTATION. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD_ANNOTATION = &quot;ancestorWordAnnotationAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION = &quot;ancestorRelationAttribute&quot;;

  /** The Constant ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION_ANNOTATION. */
  protected static final String ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION_ANNOTATION = &quot;ancestorRelationAnnotationAttribute&quot;;

  /** The Constant ITEM_TYPE_TEXT. */
  protected static final String ITEM_TYPE_TEXT = &quot;text&quot;;

  /** The Constant ITEM_TYPE_TEXT_SPLIT. */
  protected static final String ITEM_TYPE_TEXT_SPLIT = &quot;textSplit&quot;;

  /** The Constant ITEM_TYPE_UNKNOWN_ANCESTOR. */
  protected static final String ITEM_TYPE_UNKNOWN_ANCESTOR = &quot;unknownAncestor&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR. */
  protected static final String ITEM_TYPE_ANCESTOR = &quot;ancestor&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_GROUP. */
  protected static final String ITEM_TYPE_ANCESTOR_GROUP = &quot;ancestorGroup&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_GROUP_ANNOTATION. */
  protected static final String ITEM_TYPE_ANCESTOR_GROUP_ANNOTATION = &quot;ancestorGroupAnnotation&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_WORD. */
  protected static final String ITEM_TYPE_ANCESTOR_WORD = &quot;ancestorWord&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_WORD_ANNOTATION. */
  protected static final String ITEM_TYPE_ANCESTOR_WORD_ANNOTATION = &quot;ancestorWordAnnotation&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_RELATION. */
  protected static final String ITEM_TYPE_ANCESTOR_RELATION = &quot;ancestorRelation&quot;;

  /** The Constant ITEM_TYPE_ANCESTOR_RELATION_ANNOTATION. */
  protected static final String ITEM_TYPE_ANCESTOR_RELATION_ANNOTATION = &quot;ancestorRelationAnnotation&quot;;

  /** The Constant ITEM_TYPE_VARIABLE_FROM_ATTRIBUTE. */
  protected static final String ITEM_TYPE_VARIABLE_FROM_ATTRIBUTE = &quot;variableFromAttribute&quot;;

  /** The Constant VARIABLE_SUBTYPE_VALUE. */
  protected static final String VARIABLE_SUBTYPE_VALUE = &quot;value&quot;;

  /** The Constant VARIABLE_SUBTYPE_VALUE_ITEM. */
  protected static final String VARIABLE_SUBTYPE_VALUE_ITEM = &quot;item&quot;;

  /** The Constant MAPPING_SUBTYPE_TOKEN. */
  protected static final String MAPPING_SUBTYPE_TOKEN = &quot;token&quot;;

  /** The Constant MAPPING_SUBTYPE_TOKEN_PRE. */
  protected static final String MAPPING_SUBTYPE_TOKEN_PRE = &quot;pre&quot;;

  /** The Constant MAPPING_SUBTYPE_TOKEN_POST. */
  protected static final String MAPPING_SUBTYPE_TOKEN_POST = &quot;post&quot;;

  /** The Constant MAPPING_SUBTYPE_PAYLOAD. */
  protected static final String MAPPING_SUBTYPE_PAYLOAD = &quot;payload&quot;;

  /** The Constant MAPPING_SUBTYPE_CONDITION. */
  protected static final String MAPPING_SUBTYPE_CONDITION = &quot;condition&quot;;

  /** The Constant MAPPING_FILTER_UPPERCASE. */
  protected static final String MAPPING_FILTER_UPPERCASE = &quot;uppercase&quot;;

  /** The Constant MAPPING_FILTER_LOWERCASE. */
  protected static final String MAPPING_FILTER_LOWERCASE = &quot;lowercase&quot;;

  /** The Constant MAPPING_FILTER_ASCII. */
  protected static final String MAPPING_FILTER_ASCII = &quot;ascii&quot;;

  /** The Constant MAPPING_FILTER_SPLIT. */
  protected static final String MAPPING_FILTER_SPLIT = &quot;split&quot;;

  /** The Constant UPDATE_TYPE_OFFSET. */
  protected static final String UPDATE_TYPE_OFFSET = &quot;offsetUpdate&quot;;

  /** The Constant UPDATE_TYPE_POSITION. */
  protected static final String UPDATE_TYPE_POSITION = &quot;positionUpdate&quot;;

  /** The Constant UPDATE_TYPE_VARIABLE. */
  protected static final String UPDATE_TYPE_VARIABLE = &quot;variableUpdate&quot;;

  /** The Constant UPDATE_TYPE_LOCAL_REF_OFFSET_START. */
  protected static final String UPDATE_TYPE_LOCAL_REF_OFFSET_START = &quot;localRefOffsetStartUpdate&quot;;

  /** The Constant UPDATE_TYPE_LOCAL_REF_OFFSET_END. */
  protected static final String UPDATE_TYPE_LOCAL_REF_OFFSET_END = &quot;localRefOffsetEndUpdate&quot;;

  /** The Constant UPDATE_TYPE_LOCAL_REF_POSITION_START. */
  protected static final String UPDATE_TYPE_LOCAL_REF_POSITION_START = &quot;localRefPositionStartUpdate&quot;;

  /** The Constant UPDATE_TYPE_LOCAL_REF_POSITION_END. */
  protected static final String UPDATE_TYPE_LOCAL_REF_POSITION_END = &quot;localRefPositionEndUpdate&quot;;

  /** The Constant MAPPING_VALUE_VALUE. */
  protected static final String MAPPING_VALUE_VALUE = &quot;value&quot;;

  /** The Constant MAPPING_VALUE_TYPE. */
  protected static final String MAPPING_VALUE_TYPE = &quot;type&quot;;

  /** The Constant MAPPING_VALUE_NAME. */
  protected static final String MAPPING_VALUE_NAME = &quot;name&quot;;

  /** The Constant MAPPING_VALUE_NAME. */
  protected static final String MAPPING_VALUE_NAMESPACE = &quot;namespace&quot;;

  /** The Constant MAPPING_VALUE_PREFIX. */
  protected static final String MAPPING_VALUE_PREFIX = &quot;prefix&quot;;

  /** The Constant MAPPING_VALUE_FILTER. */
  protected static final String MAPPING_VALUE_FILTER = &quot;filter&quot;;

  /** The Constant MAPPING_VALUE_DISTANCE. */
  protected static final String MAPPING_VALUE_DISTANCE = &quot;distance&quot;;

  /** The Constant MAPPING_VALUE_SOURCE. */
  protected static final String MAPPING_VALUE_SOURCE = &quot;source&quot;;

  /** The Constant MAPPING_VALUE_ANCESTOR. */
  protected static final String MAPPING_VALUE_ANCESTOR = &quot;ancestor&quot;;

  /** The Constant MAPPING_VALUE_SPLIT. */
  protected static final String MAPPING_VALUE_SPLIT = &quot;split&quot;;

  /** The Constant MAPPING_VALUE_NUMBER. */
  protected static final String MAPPING_VALUE_NUMBER = &quot;number&quot;;

  /** The Constant MAPPING_VALUE_CONDITION. */
  protected static final String MAPPING_VALUE_CONDITION = &quot;condition&quot;;

  /** The Constant MAPPING_VALUE_TEXT. */
  protected static final String MAPPING_VALUE_TEXT = &quot;text&quot;;

  /** The Constant MAPPING_VALUE_NOT. */
  protected static final String MAPPING_VALUE_NOT = &quot;not&quot;;

  /** The enc. */
<span class="pc" id="L242">  private Base64.Encoder enc = Base64.getEncoder();</span>

  /** The dec. */
<span class="pc" id="L245">  private Base64.Decoder dec = Base64.getDecoder();</span>

  /**
   * Instantiates a new mtas basic parser.
   */
  public MtasBasicParser() {
<span class="nc" id="L251">    super();</span>
<span class="nc" id="L252">  }</span>

  /**
   * Instantiates a new mtas basic parser.
   *
   * @param config the config
   */
  public MtasBasicParser(MtasConfiguration config) {
<span class="fc" id="L260">    super(config);</span>
<span class="fc" id="L261">  }</span>

  /**
   * Creates the current list.
   *
   * @return the map
   */
  protected Map&lt;String, List&lt;MtasParserObject&gt;&gt; createCurrentList() {
<span class="fc" id="L269">    Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L270">    currentList.put(MAPPING_TYPE_RELATION, new ArrayList&lt;MtasParserObject&gt;());</span>
<span class="fc" id="L271">    currentList.put(MAPPING_TYPE_RELATION_ANNOTATION,</span>
        new ArrayList&lt;MtasParserObject&gt;());
<span class="fc" id="L273">    currentList.put(MAPPING_TYPE_REF, new ArrayList&lt;MtasParserObject&gt;());</span>
<span class="fc" id="L274">    currentList.put(MAPPING_TYPE_GROUP, new ArrayList&lt;MtasParserObject&gt;());</span>
<span class="fc" id="L275">    currentList.put(MAPPING_TYPE_GROUP_ANNOTATION,</span>
        new ArrayList&lt;MtasParserObject&gt;());
<span class="fc" id="L277">    currentList.put(MAPPING_TYPE_WORD, new ArrayList&lt;MtasParserObject&gt;());</span>
<span class="fc" id="L278">    currentList.put(MAPPING_TYPE_WORD_ANNOTATION,</span>
        new ArrayList&lt;MtasParserObject&gt;());
<span class="fc" id="L280">    return currentList;</span>
  }

  /**
   * Creates the update list.
   *
   * @return the map
   */
  protected Map&lt;String, Map&lt;Integer, Set&lt;String&gt;&gt;&gt; createUpdateList() {
<span class="fc" id="L289">    Map&lt;String, Map&lt;Integer, Set&lt;String&gt;&gt;&gt; updateList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L290">    updateList.put(UPDATE_TYPE_OFFSET, new HashMap&lt;&gt;());</span>
<span class="fc" id="L291">    updateList.put(UPDATE_TYPE_POSITION, new HashMap&lt;&gt;());</span>
<span class="fc" id="L292">    updateList.put(UPDATE_TYPE_LOCAL_REF_POSITION_START, new HashMap&lt;&gt;());</span>
<span class="fc" id="L293">    updateList.put(UPDATE_TYPE_LOCAL_REF_POSITION_END, new HashMap&lt;&gt;());</span>
<span class="fc" id="L294">    updateList.put(UPDATE_TYPE_LOCAL_REF_OFFSET_START, new HashMap&lt;&gt;());</span>
<span class="fc" id="L295">    updateList.put(UPDATE_TYPE_LOCAL_REF_OFFSET_END, new HashMap&lt;&gt;());</span>
<span class="fc" id="L296">    updateList.put(UPDATE_TYPE_VARIABLE, new HashMap&lt;&gt;());</span>
<span class="fc" id="L297">    return updateList;</span>
  }

  /**
   * Creates the variables.
   *
   * @return the map
   */
  protected Map&lt;String, Map&lt;String, String&gt;&gt; createVariables() {
<span class="fc" id="L306">    return new HashMap&lt;&gt;();</span>
  }

  /**
   * Compute mappings from object.
   *
   * @param mtasTokenIdFactory the mtas token id factory
   * @param object the object
   * @param currentList the current list
   * @param updateList the update list
   * @throws MtasParserException the mtas parser exception
   * @throws MtasConfigException the mtas config exception
   */
  protected void computeMappingsFromObject(
      MtasTokenIdFactory mtasTokenIdFactory, MtasParserObject object,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList,
      Map&lt;String, Map&lt;Integer, Set&lt;String&gt;&gt;&gt; updateList)
      throws MtasParserException, MtasConfigException {
<span class="fc" id="L324">    MtasParserType&lt;MtasParserMapping&lt;?&gt;&gt; objectType = object.getType();</span>
<span class="fc" id="L325">    List&lt;MtasParserMapping&lt;?&gt;&gt; mappings = objectType.getItems();</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">    if (!object.updateableMappingsWithPosition.isEmpty()) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">      for (int tokenId : object.updateableMappingsWithPosition) {</span>
<span class="nc" id="L328">        updateList.get(UPDATE_TYPE_POSITION).put(tokenId, object.getRefIds());</span>
<span class="nc" id="L329">      }</span>
    }
<span class="fc bfc" id="L331" title="All 2 branches covered.">    if (!object.updateableMappingsWithOffset.isEmpty()) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">      for (int tokenId : object.updateableMappingsWithOffset) {</span>
<span class="fc" id="L333">        updateList.get(UPDATE_TYPE_OFFSET).put(tokenId, object.getRefIds());</span>
<span class="fc" id="L334">      }</span>
    }
<span class="fc bfc" id="L336" title="All 2 branches covered.">    for (MtasParserMapping&lt;?&gt; mapping : mappings) {</span>
      try {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (mapping.getTokens().isEmpty()) {</span>
          // empty exception
        } else {
<span class="fc bfc" id="L341" title="All 2 branches covered.">          for (int i = 0; i &lt; mapping.getTokens().size(); i++) {</span>
<span class="fc" id="L342">            MtasParserMappingToken mappingToken = mapping.getTokens().get(i);</span>
            // empty exception
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (mappingToken.preValues.isEmpty()) {</span>
              // continue, but no token
            } else {
              // check conditions
<span class="fc" id="L348">              postcheckMappingConditions(object, mapping.getConditions(),</span>
                  currentList);
<span class="fc" id="L350">              boolean containsVariables = checkForVariables(</span>
                  mappingToken.preValues);
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">              containsVariables = !containsVariables</span>
<span class="pc" id="L353">                  ? checkForVariables(mappingToken.postValues)</span>
                  : containsVariables;
              // construct preValue
<span class="fc" id="L356">              String[] preValue = computeValueFromMappingValues(object,</span>
                  mappingToken.preValues, currentList, containsVariables);
              // at least preValue
<span class="pc bpc" id="L359" title="2 of 4 branches missed.">              if (preValue == null || preValue.length == 0) {</span>
<span class="nc" id="L360">                throw new MtasParserException(&quot;no preValues&quot;);</span>
              } else {
                // no delimiter in preValue
<span class="fc bfc" id="L363" title="All 2 branches covered.">                for (int k = 0; k &lt; preValue.length; k++) {</span>
<span class="fc" id="L364">                  if ((preValue[k] = preValue[k].replace(MtasToken.DELIMITER,</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">                      &quot;&quot;)).isEmpty()) {</span>
<span class="nc" id="L366">                    throw new MtasParserException(&quot;empty preValue&quot;);</span>
                  }
                }
              }
              // construct postValue
<span class="fc" id="L371">              String[] postValue = computeValueFromMappingValues(object,</span>
                  mappingToken.postValues, currentList, containsVariables);
              // construct value
              String[] value;
<span class="pc bpc" id="L375" title="1 of 4 branches missed.">              if (postValue == null || postValue.length == 0) {</span>
<span class="fc" id="L376">                value = preValue.clone();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                for (int k = 0; k &lt; value.length; k++) {</span>
<span class="fc" id="L378">                  value[k] = value[k] + MtasToken.DELIMITER;</span>
                }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">              } else if (postValue.length == 1) {</span>
<span class="fc" id="L381">                value = preValue.clone();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                for (int k = 0; k &lt; value.length; k++) {</span>
<span class="fc" id="L383">                  value[k] = value[k] + MtasToken.DELIMITER + postValue[0];</span>
                }
<span class="nc bnc" id="L385" title="All 2 branches missed.">              } else if (preValue.length == 1) {</span>
<span class="nc" id="L386">                value = postValue.clone();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                for (int k = 0; k &lt; value.length; k++) {</span>
<span class="nc" id="L388">                  value[k] = preValue[0] + MtasToken.DELIMITER + value[k];</span>
                }
              } else {
<span class="nc" id="L391">                value = new String[preValue.length * postValue.length];</span>
<span class="nc" id="L392">                int number = 0;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                for (int k1 = 0; k1 &lt; preValue.length; k1++) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                  for (int k2 = 0; k2 &lt; postValue.length; k2++) {</span>
<span class="nc" id="L395">                    value[number] = preValue[k1] + MtasToken.DELIMITER</span>
                        + postValue[k2];
<span class="nc" id="L397">                    number++;</span>
                  }
                }
              }
              // construct payload
<span class="fc" id="L402">              BytesRef payload = computePayloadFromMappingPayload(object,</span>
                  mappingToken.payload, currentList);
              // create token and get id: from now on, we must continue, no
              // exceptions allowed...
<span class="fc bfc" id="L406" title="All 2 branches covered.">              for (int k = 0; k &lt; value.length; k++) {</span>
<span class="fc" id="L407">                MtasTokenString token = new MtasTokenString(</span>
<span class="fc" id="L408">                    mtasTokenIdFactory.createTokenId(), value[k]);</span>
                // store settings offset, realoffset and parent
<span class="fc" id="L410">                token.setProvideOffset(mappingToken.offset);</span>
<span class="fc" id="L411">                token.setProvideRealOffset(mappingToken.realoffset);</span>
<span class="fc" id="L412">                token.setProvideParentId(mappingToken.parent);</span>
<span class="fc" id="L413">                String checkType = object.objectType.getType();</span>
                // register token if it contains variables
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">                if (containsVariables) {</span>
<span class="nc" id="L416">                  updateList.get(UPDATE_TYPE_VARIABLE).put(token.getId(), null);</span>
                }
                // register id for update when parent is created
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (!currentList.get(checkType).isEmpty()) {</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">                  if (currentList.get(checkType).contains(object)) {</span>
<span class="nc" id="L421">                    int listPosition = currentList.get(checkType)</span>
<span class="nc" id="L422">                        .indexOf(object);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    if (listPosition &gt; 0) {</span>
<span class="nc" id="L424">                      currentList.get(checkType).get(listPosition - 1)</span>
<span class="nc" id="L425">                          .registerUpdateableMappingAtParent(token.getId());</span>
                    }
<span class="nc" id="L427">                  } else {</span>
<span class="fc" id="L428">                    currentList.get(checkType)</span>
<span class="fc" id="L429">                        .get(currentList.get(checkType).size() - 1)</span>
<span class="fc" id="L430">                        .registerUpdateableMappingAtParent(token.getId());</span>
                  }
                  // if no real ancestor, register id update when group
                  // ancestor is created
<span class="fc bfc" id="L434" title="All 2 branches covered.">                } else if (!currentList.get(MAPPING_TYPE_GROUP).isEmpty()) {</span>
<span class="fc" id="L435">                  currentList.get(MAPPING_TYPE_GROUP)</span>
<span class="fc" id="L436">                      .get(currentList.get(MAPPING_TYPE_GROUP).size() - 1)</span>
<span class="fc" id="L437">                      .registerUpdateableMappingAtParent(token.getId());</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                } else if (!currentList.get(MAPPING_TYPE_RELATION).isEmpty()) {</span>
<span class="nc" id="L439">                  currentList.get(MAPPING_TYPE_RELATION)</span>
<span class="nc" id="L440">                      .get(currentList.get(MAPPING_TYPE_RELATION).size() - 1)</span>
<span class="nc" id="L441">                      .registerUpdateableMappingAtParent(token.getId());</span>
                }
                // update children
<span class="fc bfc" id="L444" title="All 2 branches covered.">                for (Integer tmpId : object.getUpdateableMappingsAsParent()) {</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">                  if (tokenCollection.get(tmpId) != null) {</span>
<span class="fc" id="L446">                    tokenCollection.get(tmpId).setParentId(token.getId());</span>
                  }
<span class="fc" id="L448">                }</span>
<span class="fc" id="L449">                object.resetUpdateableMappingsAsParent();</span>
                // use own position
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (mapping.position.equals(MtasParserMapping.SOURCE_OWN)) {</span>
<span class="fc" id="L452">                  token.addPositions(object.getPositions());</span>
                  // use position from ancestorGroup
<span class="fc" id="L454">                } else if (mapping.position</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_GROUP)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    &amp;&amp; (!currentList.get(MAPPING_TYPE_GROUP).isEmpty())) {</span>
<span class="nc" id="L457">                  currentList.get(MAPPING_TYPE_GROUP)</span>
<span class="nc" id="L458">                      .get(currentList.get(MAPPING_TYPE_GROUP).size() - 1)</span>
<span class="nc" id="L459">                      .addUpdateableMappingWithPosition(token.getId());</span>
                  // use position from ancestorWord
<span class="fc" id="L461">                } else if (mapping.position</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_WORD)</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                    &amp;&amp; (!currentList.get(MAPPING_TYPE_WORD).isEmpty())) {</span>
<span class="nc" id="L464">                  currentList.get(MAPPING_TYPE_WORD)</span>
<span class="nc" id="L465">                      .get(currentList.get(MAPPING_TYPE_WORD).size() - 1)</span>
<span class="nc" id="L466">                      .addUpdateableMappingWithPosition(token.getId());</span>
                  // use position from ancestorRelation
<span class="fc" id="L468">                } else if (mapping.position</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    &amp;&amp; (!currentList.get(MAPPING_TYPE_RELATION).isEmpty())) {</span>
<span class="nc" id="L471">                  currentList.get(MAPPING_TYPE_RELATION)</span>
<span class="nc" id="L472">                      .get(currentList.get(MAPPING_TYPE_RELATION).size() - 1)</span>
<span class="nc" id="L473">                      .addUpdateableMappingWithPosition(token.getId());</span>
                  // register id to get positions later from references
<span class="fc" id="L475">                } else if (mapping.position</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_REFS)) {</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                  if (mapping.type.equals(MAPPING_TYPE_GROUP_ANNOTATION)) {</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">                    if (mapping.start != null &amp;&amp; mapping.end != null) {</span>
<span class="nc" id="L479">                      String start = object.getAttribute(mapping.start);</span>
<span class="nc" id="L480">                      String end = object.getAttribute(mapping.end);</span>
<span class="nc bnc" id="L481" title="All 6 branches missed.">                      if (start != null &amp;&amp; !start.isEmpty() &amp;&amp; end != null</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                          &amp;&amp; !end.isEmpty()) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                        if (start.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L484">                          start = start.substring(1);</span>
                        }
<span class="nc bnc" id="L486" title="All 2 branches missed.">                        if (end.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L487">                          end = end.substring(1);</span>
                        }
<span class="nc" id="L489">                        updateList.get(UPDATE_TYPE_LOCAL_REF_POSITION_START)</span>
<span class="nc" id="L490">                            .put(token.getId(),</span>
<span class="nc" id="L491">                                new HashSet&lt;String&gt;(Arrays.asList(start)));</span>
<span class="nc" id="L492">                        updateList.get(UPDATE_TYPE_LOCAL_REF_POSITION_END).put(</span>
<span class="nc" id="L493">                            token.getId(),</span>
<span class="nc" id="L494">                            new HashSet&lt;String&gt;(Arrays.asList(end)));</span>
<span class="nc" id="L495">                        updateList.get(UPDATE_TYPE_LOCAL_REF_OFFSET_START).put(</span>
<span class="nc" id="L496">                            token.getId(),</span>
<span class="nc" id="L497">                            new HashSet&lt;String&gt;(Arrays.asList(start)));</span>
<span class="nc" id="L498">                        updateList.get(UPDATE_TYPE_LOCAL_REF_OFFSET_END).put(</span>
<span class="nc" id="L499">                            token.getId(),</span>
<span class="nc" id="L500">                            new HashSet&lt;String&gt;(Arrays.asList(end)));</span>
                      }
<span class="nc" id="L502">                    }</span>
                  } else {
<span class="fc" id="L504">                    updateList.get(UPDATE_TYPE_POSITION).put(token.getId(),</span>
<span class="fc" id="L505">                        object.getRefIds());</span>
                  }
                } else {
                  // should not happen
                }
                // use own offset
<span class="fc bfc" id="L511" title="All 2 branches covered.">                if (mapping.offset.equals(MtasParserMapping.SOURCE_OWN)) {</span>
<span class="fc" id="L512">                  token.setOffset(object.getOffsetStart(),</span>
<span class="fc" id="L513">                      object.getOffsetEnd());</span>
                  // use offset from ancestorGroup
<span class="fc" id="L515">                } else if (mapping.offset</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_GROUP)</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    &amp;&amp; (!currentList.get(MAPPING_TYPE_GROUP).isEmpty())) {</span>
<span class="nc" id="L518">                  currentList.get(MAPPING_TYPE_GROUP)</span>
<span class="nc" id="L519">                      .get(currentList.get(MAPPING_TYPE_GROUP).size() - 1)</span>
<span class="nc" id="L520">                      .addUpdateableMappingWithOffset(token.getId());</span>
                  // use offset from ancestorWord
<span class="fc" id="L522">                } else if (mapping.offset</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_WORD)</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">                    &amp;&amp; !currentList.get(MAPPING_TYPE_WORD).isEmpty()) {</span>
<span class="fc" id="L525">                  currentList.get(MAPPING_TYPE_WORD)</span>
<span class="fc" id="L526">                      .get(currentList.get(MAPPING_TYPE_WORD).size() - 1)</span>
<span class="fc" id="L527">                      .addUpdateableMappingWithOffset(token.getId());</span>
                  // use offset from ancestorRelation
<span class="fc" id="L529">                } else if (mapping.offset</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                    &amp;&amp; !currentList.get(MAPPING_TYPE_RELATION).isEmpty()) {</span>
<span class="nc" id="L532">                  currentList.get(MAPPING_TYPE_RELATION)</span>
<span class="nc" id="L533">                      .get(currentList.get(MAPPING_TYPE_RELATION).size() - 1)</span>
<span class="nc" id="L534">                      .addUpdateableMappingWithOffset(token.getId());</span>
                  // register id to get offset later from refs
<span class="fc" id="L536">                } else if (mapping.offset</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">                    .equals(MtasParserMapping.SOURCE_REFS)) {</span>
<span class="fc" id="L538">                  updateList.get(UPDATE_TYPE_OFFSET).put(token.getId(),</span>
<span class="fc" id="L539">                      object.getRefIds());</span>
                }
                // always use own realOffset
<span class="fc" id="L542">                token.setRealOffset(object.getRealOffsetStart(),</span>
<span class="fc" id="L543">                    object.getRealOffsetEnd());</span>
                // set payload
<span class="fc" id="L545">                token.setPayload(payload);</span>
                // add token to collection
<span class="fc" id="L547">                tokenCollection.add(token);</span>
              }
            }
          }
        }
        // register start and end
<span class="pc bpc" id="L553" title="3 of 4 branches missed.">        if (mapping.start != null &amp;&amp; mapping.end != null) {</span>
<span class="nc" id="L554">          String startAttribute = null;</span>
<span class="nc" id="L555">          String endAttribute = null;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">          if (mapping.start.equals(&quot;#&quot;)) {</span>
<span class="nc" id="L557">            startAttribute = object.getId();</span>
          } else {
<span class="nc" id="L559">            startAttribute = object.getAttribute(mapping.start);</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">            if (startAttribute != null &amp;&amp; startAttribute.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L561">              startAttribute = startAttribute.substring(1);</span>
            }
          }
<span class="nc bnc" id="L564" title="All 2 branches missed.">          if (mapping.end.equals(&quot;#&quot;)) {</span>
<span class="nc" id="L565">            endAttribute = object.getId();</span>
          } else {
<span class="nc" id="L567">            endAttribute = object.getAttribute(mapping.end);</span>
<span class="nc bnc" id="L568" title="All 4 branches missed.">            if (endAttribute != null &amp;&amp; endAttribute.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L569">              endAttribute = endAttribute.substring(1);</span>
            }
          }
<span class="nc bnc" id="L572" title="All 4 branches missed.">          if (startAttribute != null &amp;&amp; endAttribute != null</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">              &amp;&amp; !object.getPositions().isEmpty()) {</span>
<span class="nc" id="L574">            object.setReferredStartPosition(startAttribute,</span>
<span class="nc" id="L575">                object.getPositions().first());</span>
<span class="nc" id="L576">            object.setReferredEndPosition(endAttribute,</span>
<span class="nc" id="L577">                object.getPositions().last());</span>
<span class="nc" id="L578">            object.setReferredStartOffset(startAttribute,</span>
<span class="nc" id="L579">                object.getOffsetStart());</span>
<span class="nc" id="L580">            object.setReferredEndOffset(endAttribute, object.getOffsetEnd());</span>
          }
        }
<span class="fc" id="L583">      } catch (MtasParserException e) {</span>
<span class="fc" id="L584">        log.debug(&quot;Rejected mapping &quot; + object.getType().getName(), e);</span>
        // ignore, no new token is created
<span class="fc" id="L586">      }</span>
<span class="fc" id="L587">    }</span>
    // copy remaining updateableMappings to new parent
<span class="fc bfc" id="L589" title="All 2 branches covered.">    if (!currentList.get(objectType.getType()).isEmpty()) {</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">      if (currentList.get(objectType.getType()).contains(object)) {</span>
<span class="nc" id="L591">        int listPosition = currentList.get(objectType.getType())</span>
<span class="nc" id="L592">            .indexOf(object);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (listPosition &gt; 0) {</span>
<span class="nc" id="L594">          currentList.get(objectType.getType()).get(listPosition - 1)</span>
<span class="nc" id="L595">              .registerUpdateableMappingsAtParent(</span>
<span class="nc" id="L596">                  object.getUpdateableMappingsAsParent());</span>
        }
<span class="nc" id="L598">      } else {</span>
<span class="fc" id="L599">        currentList.get(objectType.getType())</span>
<span class="fc" id="L600">            .get(currentList.get(objectType.getType()).size() - 1)</span>
<span class="fc" id="L601">            .registerUpdateableMappingsAtParent(</span>
<span class="fc" id="L602">                object.getUpdateableMappingsAsParent());</span>
      }
<span class="fc bfc" id="L604" title="All 2 branches covered.">    } else if (!currentList.get(MAPPING_TYPE_GROUP).isEmpty()) {</span>
<span class="fc" id="L605">      currentList.get(MAPPING_TYPE_GROUP)</span>
<span class="fc" id="L606">          .get(currentList.get(MAPPING_TYPE_GROUP).size() - 1)</span>
<span class="fc" id="L607">          .registerUpdateableMappingsAtParent(</span>
<span class="fc" id="L608">              object.getUpdateableMappingsAsParent());</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">    } else if (!currentList.get(MAPPING_TYPE_RELATION).isEmpty()) {</span>
<span class="nc" id="L610">      currentList.get(MAPPING_TYPE_RELATION)</span>
<span class="nc" id="L611">          .get(currentList.get(MAPPING_TYPE_RELATION).size() - 1)</span>
<span class="nc" id="L612">          .registerUpdateableMappingsAtParent(</span>
<span class="nc" id="L613">              object.getUpdateableMappingsAsParent());</span>
    }
<span class="fc" id="L615">    updateMappingsWithLocalReferences(object, currentList, updateList);</span>
<span class="fc" id="L616">  }</span>

  /**
   * Compute variables from object.
   *
   * @param object the object
   * @param currentList the current list
   * @param variables the variables
   */
  protected void computeVariablesFromObject(MtasParserObject object,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList,
      Map&lt;String, Map&lt;String, String&gt;&gt; variables) {
<span class="nc" id="L628">    MtasParserType&lt;MtasParserVariable&gt; parserType = object.getType();</span>
<span class="nc" id="L629">    String id = object.getId();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">    if (id != null) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">      for (MtasParserVariable variable : parserType.getItems()) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (!variables.containsKey(variable.variable)) {</span>
<span class="nc" id="L633">          variables.put(variable.variable, new HashMap&lt;String, String&gt;());</span>
        }
<span class="nc" id="L635">        StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        for (MtasParserVariableValue variableValue : variable.values) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">          if (variableValue.type.equals(&quot;attribute&quot;)) {</span>
<span class="nc" id="L638">            String subValue = object.getAttribute(variableValue.name);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (subValue != null) {</span>
<span class="nc" id="L640">              builder.append(subValue);</span>
            }
          }
<span class="nc" id="L643">        }</span>
<span class="nc" id="L644">        variables.get(variable.variable).put(id, builder.toString());</span>
<span class="nc" id="L645">      }</span>
    }
<span class="nc" id="L647">  }</span>

  /**
   * Check for variables.
   *
   * @param values the values
   * @return true, if successful
   */
  private boolean checkForVariables(List&lt;Map&lt;String, String&gt;&gt; values) {
<span class="pc bpc" id="L656" title="1 of 4 branches missed.">    if (values == null || values.isEmpty()) {</span>
<span class="fc" id="L657">      return false;</span>
    } else {
<span class="fc bfc" id="L659" title="All 2 branches covered.">      for (Map&lt;String, String&gt; list : values) {</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">        if (list.containsKey(&quot;type&quot;) &amp;&amp; list.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            .equals(MtasParserMapping.PARSER_TYPE_VARIABLE)) {</span>
<span class="nc" id="L662">          return true;</span>
        }
<span class="fc" id="L664">      }</span>
    }
<span class="fc" id="L666">    return false;</span>
  }

  /**
   * Update mappings with local references.
   *
   * @param currentObject the current object
   * @param currentList the current list
   * @param updateList the update list
   */
  private void updateMappingsWithLocalReferences(MtasParserObject currentObject,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList,
      Map&lt;String, Map&lt;Integer, Set&lt;String&gt;&gt;&gt; updateList) {
<span class="fc bfc" id="L679" title="All 2 branches covered.">    if (currentObject.getType().type.equals(MAPPING_TYPE_GROUP)) {</span>
      for (Integer tokenId : updateList
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">          .get(UPDATE_TYPE_LOCAL_REF_POSITION_START).keySet()) {</span>
<span class="nc" id="L682">        if (updateList.get(UPDATE_TYPE_LOCAL_REF_POSITION_END)</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            .containsKey(tokenId)</span>
<span class="nc" id="L684">            &amp;&amp; updateList.get(UPDATE_TYPE_LOCAL_REF_OFFSET_START)</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                .containsKey(tokenId)</span>
<span class="nc" id="L686">            &amp;&amp; updateList.get(UPDATE_TYPE_LOCAL_REF_OFFSET_END)</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">                .containsKey(tokenId)) {</span>
<span class="nc" id="L688">          Iterator&lt;String&gt; startPositionIt = updateList</span>
<span class="nc" id="L689">              .get(UPDATE_TYPE_LOCAL_REF_POSITION_START).get(tokenId)</span>
<span class="nc" id="L690">              .iterator();</span>
<span class="nc" id="L691">          Iterator&lt;String&gt; endPositionIt = updateList</span>
<span class="nc" id="L692">              .get(UPDATE_TYPE_LOCAL_REF_POSITION_END).get(tokenId).iterator();</span>
<span class="nc" id="L693">          Iterator&lt;String&gt; startOffsetIt = updateList</span>
<span class="nc" id="L694">              .get(UPDATE_TYPE_LOCAL_REF_OFFSET_START).get(tokenId).iterator();</span>
<span class="nc" id="L695">          Iterator&lt;String&gt; endOffsetIt = updateList</span>
<span class="nc" id="L696">              .get(UPDATE_TYPE_LOCAL_REF_OFFSET_END).get(tokenId).iterator();</span>
<span class="nc" id="L697">          Integer startPosition = null;</span>
<span class="nc" id="L698">          Integer endPosition = null;</span>
<span class="nc" id="L699">          Integer startOffset = null;</span>
<span class="nc" id="L700">          Integer endOffset = null;</span>
<span class="nc" id="L701">          Integer newValue = null;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">          while (startPositionIt.hasNext()) {</span>
<span class="nc" id="L703">            String localKey = startPositionIt.next();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (currentObject.referredStartPosition.containsKey(localKey)) {</span>
<span class="nc" id="L705">              newValue = currentObject.referredStartPosition.get(localKey);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">              startPosition = (startPosition == null) ? newValue</span>
<span class="nc" id="L707">                  : Math.min(startPosition, newValue);</span>
            }
<span class="nc" id="L709">          }</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">          while (endPositionIt.hasNext()) {</span>
<span class="nc" id="L711">            String localKey = endPositionIt.next();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (currentObject.referredEndPosition.containsKey(localKey)) {</span>
<span class="nc" id="L713">              newValue = currentObject.referredEndPosition.get(localKey);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">              endPosition = (endPosition == null) ? newValue</span>
<span class="nc" id="L715">                  : Math.max(endPosition, newValue);</span>
            }
<span class="nc" id="L717">          }</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">          while (startOffsetIt.hasNext()) {</span>
<span class="nc" id="L719">            String localKey = startOffsetIt.next();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (currentObject.referredStartOffset.containsKey(localKey)) {</span>
<span class="nc" id="L721">              newValue = currentObject.referredStartOffset.get(localKey);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">              startOffset = (startOffset == null) ? newValue</span>
<span class="nc" id="L723">                  : Math.min(startOffset, newValue);</span>
            }
<span class="nc" id="L725">          }</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">          while (endOffsetIt.hasNext()) {</span>
<span class="nc" id="L727">            String localKey = endOffsetIt.next();</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (currentObject.referredEndOffset.containsKey(localKey)) {</span>
<span class="nc" id="L729">              newValue = currentObject.referredEndOffset.get(localKey);</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">              endOffset = (endOffset == null) ? newValue</span>
<span class="nc" id="L731">                  : Math.max(endOffset, newValue);</span>
            }
<span class="nc" id="L733">          }</span>
<span class="nc bnc" id="L734" title="All 8 branches missed.">          if (startPosition != null &amp;&amp; endPosition != null</span>
              &amp;&amp; startOffset != null &amp;&amp; endOffset != null) {
<span class="nc" id="L736">            MtasToken token = tokenCollection.get(tokenId);</span>
<span class="nc" id="L737">            token.addPositionRange(startPosition, endPosition);</span>
<span class="nc" id="L738">            token.setOffset(startOffset, endOffset);</span>
          }
        }
<span class="nc" id="L741">      }</span>

    }
<span class="fc bfc" id="L744" title="All 2 branches covered.">    if (!currentList.get(MAPPING_TYPE_GROUP).isEmpty()) {</span>
<span class="fc" id="L745">      MtasParserObject parentGroup = currentList.get(MAPPING_TYPE_GROUP)</span>
<span class="fc" id="L746">          .get(currentList.get(MAPPING_TYPE_GROUP).size() - 1);</span>
<span class="fc" id="L747">      parentGroup.referredStartPosition</span>
<span class="fc" id="L748">          .putAll(currentObject.referredStartPosition);</span>
<span class="fc" id="L749">      parentGroup.referredEndPosition.putAll(currentObject.referredEndPosition);</span>
<span class="fc" id="L750">      parentGroup.referredStartOffset.putAll(currentObject.referredStartOffset);</span>
<span class="fc" id="L751">      parentGroup.referredEndOffset.putAll(currentObject.referredEndOffset);</span>
    }
<span class="fc" id="L753">    currentObject.referredStartPosition.clear();</span>
<span class="fc" id="L754">    currentObject.referredEndPosition.clear();</span>
<span class="fc" id="L755">    currentObject.referredStartOffset.clear();</span>
<span class="fc" id="L756">    currentObject.referredEndOffset.clear();</span>
<span class="fc" id="L757">  }</span>

  /**
   * Compute type from mapping source.
   *
   * @param source the source
   * @return the string
   * @throws MtasParserException the mtas parser exception
   */
  private String computeTypeFromMappingSource(String source)
      throws MtasParserException {
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">    if (source.equals(MtasParserMapping.SOURCE_OWN)) {</span>
<span class="nc" id="L769">      return null;</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">    } else if (source.equals(MtasParserMapping.SOURCE_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L771">      return MAPPING_TYPE_GROUP;</span>
<span class="fc" id="L772">    } else if (source</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">        .equals(MtasParserMapping.SOURCE_ANCESTOR_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L774">      return MAPPING_TYPE_GROUP_ANNOTATION;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">    } else if (source.equals(MtasParserMapping.SOURCE_ANCESTOR_WORD)) {</span>
<span class="fc" id="L776">      return MAPPING_TYPE_WORD;</span>
<span class="fc" id="L777">    } else if (source</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        .equals(MtasParserMapping.SOURCE_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="fc" id="L779">      return MAPPING_TYPE_WORD_ANNOTATION;</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">    } else if (source.equals(MtasParserMapping.SOURCE_ANCESTOR_RELATION)) {</span>
<span class="fc" id="L781">      return MAPPING_TYPE_RELATION;</span>
<span class="nc" id="L782">    } else if (source</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        .equals(MtasParserMapping.SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L784">      return MAPPING_TYPE_RELATION_ANNOTATION;</span>
    } else {
<span class="nc" id="L786">      throw new MtasParserException(&quot;unknown source &quot; + source);</span>
    }
  }

  /**
   * Compute object from mapping value.
   *
   * @param object the object
   * @param mappingValue the mapping value
   * @param currentList the current list
   * @return the mtas parser object[]
   * @throws MtasParserException the mtas parser exception
   */
  private MtasParserObject[] computeObjectFromMappingValue(
      MtasParserObject object, Map&lt;String, String&gt; mappingValue,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList)
      throws MtasParserException {
<span class="fc" id="L803">    MtasParserObject[] checkObjects = null;</span>
    MtasParserObject checkObject;
<span class="fc" id="L805">    Integer ancestorNumber = null;</span>
<span class="fc" id="L806">    String ancestorType = null;</span>
    // try to get relevant object
<span class="fc" id="L808">    if (mappingValue.get(MAPPING_VALUE_SOURCE)</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">        .equals(MtasParserMapping.SOURCE_OWN)) {</span>
<span class="fc" id="L810">      checkObjects = new MtasParserObject[] { object };</span>
    } else {
<span class="fc bfc" id="L812" title="All 2 branches covered.">      ancestorNumber = mappingValue.get(MAPPING_VALUE_ANCESTOR) != null</span>
<span class="fc" id="L813">          ? Integer.parseInt(mappingValue.get(MAPPING_VALUE_ANCESTOR)) : null;</span>
<span class="fc" id="L814">      ancestorType = computeTypeFromMappingSource(</span>
<span class="fc" id="L815">          mappingValue.get(MAPPING_VALUE_SOURCE));</span>
      // get ancestor object
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">      if (ancestorType != null) {</span>
<span class="fc" id="L818">        int s = currentList.get(ancestorType).size();</span>
        // check existence ancestor for conditions
<span class="fc bfc" id="L820" title="All 2 branches covered.">        if (ancestorNumber != null) {</span>
<span class="pc bpc" id="L821" title="1 of 4 branches missed.">          if ((s &gt; 0) &amp;&amp; (ancestorNumber &lt; s) &amp;&amp; (checkObject = currentList</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">              .get(ancestorType).get((s - ancestorNumber - 1))) != null) {</span>
<span class="fc" id="L823">            checkObjects = new MtasParserObject[] { checkObject };</span>
          }
        } else {
<span class="fc" id="L826">          checkObjects = new MtasParserObject[s];</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">          for (int i = s - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L828">            checkObjects[s - i - 1] = currentList.get(ancestorType).get(i);</span>
          }
        }
      }
    }
<span class="fc" id="L833">    return checkObjects;</span>
  }

  /**
   * Compute value from mapping values.
   *
   * @param object the object
   * @param mappingValues the mapping values
   * @param currentList the current list
   * @param containsVariables the contains variables
   * @return the string[]
   * @throws MtasParserException the mtas parser exception
   * @throws MtasConfigException the mtas config exception
   */
  private String[] computeValueFromMappingValues(MtasParserObject object,
      List&lt;Map&lt;String, String&gt;&gt; mappingValues,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList,
      boolean containsVariables)
      throws MtasParserException, MtasConfigException {
<span class="fc" id="L852">    String[] value = { &quot;&quot; };</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">    for (Map&lt;String, String&gt; mappingValue : mappingValues) {</span>
      // directly
<span class="fc" id="L855">      if (mappingValue.get(MAPPING_VALUE_SOURCE)</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">          .equals(MtasParserMapping.SOURCE_STRING)) {</span>
<span class="fc" id="L857">        if (mappingValue.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">            .equals(MtasParserMapping.PARSER_TYPE_STRING)) {</span>
<span class="fc" id="L859">          String subvalue = computeFilteredPrefixedValue(</span>
<span class="fc" id="L860">              mappingValue.get(MAPPING_VALUE_TYPE),</span>
<span class="fc" id="L861">              mappingValue.get(MAPPING_VALUE_TEXT), null, null);</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">          if (subvalue != null) {</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">            for (int i = 0; i &lt; value.length; i++) {</span>
<span class="fc" id="L864">              value[i] = addAndEncodeValue(value[i], subvalue,</span>
                  containsVariables);
            }
          }
<span class="fc" id="L868">        }</span>
        // from objects
      } else {
<span class="fc" id="L871">        MtasParserObject[] checkObjects = computeObjectFromMappingValue(object,</span>
            mappingValue, currentList);
        // create value
<span class="pc bpc" id="L874" title="2 of 4 branches missed.">        if (checkObjects != null &amp;&amp; checkObjects.length &gt; 0) {</span>
<span class="fc" id="L875">          MtasParserType checkType = checkObjects[0].getType();</span>
          // add name to value
<span class="fc" id="L877">          if (mappingValue.get(MAPPING_VALUE_TYPE)</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">              .equals(MtasParserMapping.PARSER_TYPE_NAME)) {</span>
<span class="fc" id="L879">            String subvalue = computeFilteredPrefixedValue(</span>
<span class="fc" id="L880">                mappingValue.get(MAPPING_VALUE_TYPE), checkType.getName(),</span>
<span class="fc" id="L881">                mappingValue.get(MAPPING_VALUE_FILTER),</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">                mappingValue.get(MAPPING_VALUE_PREFIX) == null</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">                    || mappingValue.get(MAPPING_VALUE_PREFIX).isEmpty() ? null</span>
<span class="fc" id="L884">                        : mappingValue.get(MAPPING_VALUE_PREFIX));</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">            if (subvalue != null) {</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">              for (int i = 0; i &lt; value.length; i++) {</span>
<span class="fc" id="L887">                value[i] = addAndEncodeValue(value[i], subvalue,</span>
                    containsVariables);
              }
            }
            // add attribute to value
<span class="fc" id="L892">          } else if (mappingValue.get(MAPPING_VALUE_TYPE)</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">              .equals(MtasParserMapping.PARSER_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L894">            String tmpValue = null;    </span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            if (mappingValue.get(MAPPING_VALUE_NAME).equals(&quot;#&quot;)) {</span>
<span class="nc" id="L896">              tmpValue = checkObjects[0].getId();</span>
            } else {
<span class="fc" id="L898">              String namespace = mappingValue.get(MAPPING_VALUE_NAMESPACE); </span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">              if(namespace==null) {</span>
<span class="fc" id="L900">                tmpValue = checkObjects[0]</span>
<span class="fc" id="L901">                  .getAttribute(mappingValue.get(MAPPING_VALUE_NAME));</span>
              } else {
<span class="nc" id="L903">                tmpValue = checkObjects[0]</span>
<span class="nc" id="L904">                    .getOtherAttribute(namespace, mappingValue.get(MAPPING_VALUE_NAME));</span>
              }
            }
<span class="fc" id="L907">            String subvalue = computeFilteredPrefixedValue(</span>
<span class="fc" id="L908">                mappingValue.get(MAPPING_VALUE_TYPE), tmpValue,</span>
<span class="fc" id="L909">                mappingValue.get(MAPPING_VALUE_FILTER),</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">                mappingValue.get(MAPPING_VALUE_PREFIX) == null</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">                    || mappingValue.get(MAPPING_VALUE_PREFIX).isEmpty() ? null</span>
<span class="fc" id="L912">                        : mappingValue.get(MAPPING_VALUE_PREFIX));</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (subvalue != null) {</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">              for (int i = 0; i &lt; value.length; i++) {</span>
<span class="fc" id="L915">                value[i] = addAndEncodeValue(value[i], subvalue,</span>
                    containsVariables);
              }
            }
            // value from text
<span class="fc" id="L920">          } else if (mappingValue.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">              .equals(MtasParserMapping.PARSER_TYPE_TEXT)) {</span>
<span class="fc" id="L922">            String subvalue = computeFilteredPrefixedValue(</span>
<span class="fc" id="L923">                mappingValue.get(MAPPING_VALUE_TYPE), checkObjects[0].getText(),</span>
<span class="fc" id="L924">                mappingValue.get(MAPPING_VALUE_FILTER),</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">                mappingValue.get(MAPPING_VALUE_PREFIX) == null</span>
<span class="pc bnc" id="L926" title="All 2 branches missed.">                    || mappingValue.get(MAPPING_VALUE_PREFIX).isEmpty() ? null</span>
<span class="nc" id="L927">                        : mappingValue.get(MAPPING_VALUE_PREFIX));</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">            if (subvalue != null) {</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">              for (int i = 0; i &lt; value.length; i++) {</span>
<span class="fc" id="L930">                value[i] = addAndEncodeValue(value[i], subvalue,</span>
                    containsVariables);
              }
            }
<span class="pc" id="L934">          } else if (mappingValue.get(&quot;type&quot;)</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">              .equals(MtasParserMapping.PARSER_TYPE_TEXT_SPLIT)) {</span>
<span class="nc" id="L936">            String[] textValues = checkObjects[0].getText()</span>
<span class="nc" id="L937">                .split(Pattern.quote(mappingValue.get(MAPPING_VALUE_SPLIT)));</span>
<span class="nc" id="L938">            textValues = computeFilteredSplitValues(textValues,</span>
<span class="nc" id="L939">                mappingValue.get(MAPPING_VALUE_FILTER));</span>
<span class="nc bnc" id="L940" title="All 4 branches missed.">            if (textValues != null &amp;&amp; textValues.length &gt; 0) {</span>
<span class="nc" id="L941">              String[] nextValue = new String[value.length * textValues.length];</span>
<span class="nc" id="L942">              boolean nullValue = false;</span>
<span class="nc" id="L943">              int number = 0;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">              for (int k = 0; k &lt; textValues.length; k++) {</span>
<span class="nc" id="L945">                String subvalue = computeFilteredPrefixedValue(</span>
<span class="nc" id="L946">                    mappingValue.get(MAPPING_VALUE_TYPE), textValues[k],</span>
<span class="nc" id="L947">                    mappingValue.get(MAPPING_VALUE_FILTER),</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">                    mappingValue.get(MAPPING_VALUE_PREFIX) == null</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                        || mappingValue.get(MAPPING_VALUE_PREFIX).isEmpty()</span>
<span class="nc" id="L950">                            ? null : mappingValue.get(MAPPING_VALUE_PREFIX));</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (subvalue != null) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">                  for (int i = 0; i &lt; value.length; i++) {</span>
<span class="nc" id="L953">                    nextValue[number] = addAndEncodeValue(value[i], subvalue,</span>
                        containsVariables);
<span class="nc" id="L955">                    number++;</span>
                  }
<span class="nc bnc" id="L957" title="All 2 branches missed.">                } else if (!nullValue) {</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                  for (int i = 0; i &lt; value.length; i++) {</span>
<span class="nc" id="L959">                    nextValue[number] = value[i];</span>
<span class="nc" id="L960">                    number++;</span>
                  }
<span class="nc" id="L962">                  nullValue = true;</span>
                }
              }
<span class="nc" id="L965">              value = new String[number];</span>
<span class="nc" id="L966">              System.arraycopy(nextValue, 0, value, 0, number);</span>
            }
<span class="nc" id="L968">          } else if (mappingValue.get(&quot;type&quot;)</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">              .equals(MtasParserMapping.PARSER_TYPE_VARIABLE)) {</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">            if (containsVariables) {</span>
<span class="nc" id="L971">              String variableName = mappingValue.get(MAPPING_VALUE_NAME);</span>
<span class="nc" id="L972">              String variableValue = mappingValue.get(MAPPING_VALUE_VALUE);</span>
<span class="nc" id="L973">              String prefix = mappingValue.get(MAPPING_VALUE_PREFIX);</span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">              if (variableName != null &amp;&amp; variableValue != null</span>
<span class="nc" id="L975">                  &amp;&amp; mappingValue.get(MAPPING_VALUE_SOURCE)</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                      .equals(MtasParserMapping.SOURCE_OWN)) {</span>
<span class="nc" id="L977">                String subvalue = object.getAttribute(variableValue);</span>
<span class="nc bnc" id="L978" title="All 4 branches missed.">                if (subvalue != null &amp;&amp; subvalue.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L979">                  subvalue = subvalue.substring(1);</span>
                }
<span class="nc bnc" id="L981" title="All 2 branches missed.">                if (subvalue != null) {</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">                  for (int i = 0; i &lt; value.length; i++) {</span>
<span class="nc bnc" id="L983" title="All 4 branches missed.">                    if (prefix != null &amp;&amp; !prefix.isEmpty()) {</span>
<span class="nc" id="L984">                      value[i] = addAndEncodeValue(value[i], prefix,</span>
                          containsVariables);
                    }
<span class="nc" id="L987">                    value[i] = addAndEncodeVariable(value[i], variableName,</span>
                        subvalue, containsVariables);
                  }
                }
              }
<span class="nc" id="L992">            } else {</span>
<span class="nc" id="L993">              throw new MtasParserException(&quot;unexpected variable&quot;);</span>
            }
          } else {
<span class="nc" id="L996">            throw new MtasParserException(</span>
<span class="nc" id="L997">                &quot;unknown type &quot; + mappingValue.get(&quot;type&quot;));</span>
          }
        }
      }
<span class="fc" id="L1001">    }</span>
<span class="pc bpc" id="L1002" title="1 of 4 branches missed.">    if (value.length == 1 &amp;&amp; value[0].isEmpty()) {</span>
<span class="fc" id="L1003">      return new String[] {};</span>
    } else {
<span class="fc" id="L1005">      return value;</span>
    }
  }

  /**
   * Adds the and encode variable.
   *
   * @param originalValue the original value
   * @param newVariable the new variable
   * @param newVariableName the new variable name
   * @param encode the encode
   * @return the string
   */
  private String addAndEncodeVariable(String originalValue, String newVariable,
      String newVariableName, boolean encode) {
<span class="nc" id="L1020">    return addAndEncode(originalValue, newVariable, newVariableName, encode);</span>
  }

  /**
   * Adds the and encode value.
   *
   * @param originalValue the original value
   * @param newValue the new value
   * @param encode the encode
   * @return the string
   */
  private String addAndEncodeValue(String originalValue, String newValue,
      boolean encode) {
<span class="fc" id="L1033">    return addAndEncode(originalValue, null, newValue, encode);</span>
  }

  /**
   * Adds the and encode.
   *
   * @param originalValue the original value
   * @param newType the new type
   * @param newValue the new value
   * @param encode the encode
   * @return the string
   */
  private String addAndEncode(String originalValue, String newType,
      String newValue, boolean encode) {
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">    if (newValue == null) {</span>
<span class="nc" id="L1048">      return originalValue;</span>
    } else {
      String finalNewValue;
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">      if (encode) {</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        if (newType == null) {</span>
<span class="nc" id="L1053">          finalNewValue = new String(</span>
<span class="nc" id="L1054">              enc.encode(newValue.getBytes(StandardCharsets.UTF_8)),</span>
              StandardCharsets.UTF_8);
        } else {
<span class="nc" id="L1057">          finalNewValue = new String(</span>
<span class="nc" id="L1058">              enc.encode(newType.getBytes(StandardCharsets.UTF_8)),</span>
              StandardCharsets.UTF_8)
              + &quot;:&quot;
              + new String(
<span class="nc" id="L1062">                  enc.encode(newValue.getBytes(StandardCharsets.UTF_8)),</span>
                  StandardCharsets.UTF_8);
        }
      } else {
<span class="fc" id="L1066">        finalNewValue = newValue;</span>
      }
<span class="pc bpc" id="L1068" title="1 of 4 branches missed.">      if (originalValue == null || originalValue.isEmpty()) {</span>
<span class="fc" id="L1069">        return finalNewValue;</span>
      } else {
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        return originalValue + (encode ? &quot; &quot; : &quot;&quot;) + finalNewValue;</span>
      }
    }
  }

  /**
   * Decode and update with variables.
   *
   * @param encodedPrefix the encoded prefix
   * @param encodedPostfix the encoded postfix
   * @param variables the variables
   * @return the string
   */
  protected String decodeAndUpdateWithVariables(String encodedPrefix,
      String encodedPostfix, Map&lt;String, Map&lt;String, String&gt;&gt; variables) {
    String[] prefixSplit;
    String[] postfixSplit;
<span class="nc bnc" id="L1088" title="All 4 branches missed.">    if (encodedPrefix != null &amp;&amp; !encodedPrefix.isEmpty()) {</span>
<span class="nc" id="L1089">      prefixSplit = encodedPrefix.split(&quot; &quot;);</span>
    } else {
<span class="nc" id="L1091">      prefixSplit = new String[0];</span>
    }
<span class="nc bnc" id="L1093" title="All 4 branches missed.">    if (encodedPostfix != null &amp;&amp; !encodedPostfix.isEmpty()) {</span>
<span class="nc" id="L1094">      postfixSplit = encodedPostfix.split(&quot; &quot;);</span>
    } else {
<span class="nc" id="L1096">      postfixSplit = new String[0];</span>
    }
    try {
<span class="nc" id="L1099">      String prefix = decodeAndUpdateWithVariables(prefixSplit, variables);</span>
<span class="nc" id="L1100">      String postfix = decodeAndUpdateWithVariables(postfixSplit, variables);</span>
<span class="nc" id="L1101">      return prefix + MtasToken.DELIMITER + postfix;</span>
<span class="nc" id="L1102">    } catch (MtasParserException e) {</span>
<span class="nc" id="L1103">      log.debug(e);</span>
<span class="nc" id="L1104">      return null;</span>
    }
  }

  /**
   * Decode and update with variables.
   *
   * @param splitList the split list
   * @param variables the variables
   * @return the string
   * @throws MtasParserException the mtas parser exception
   */
  private String decodeAndUpdateWithVariables(String[] splitList,
      Map&lt;String, Map&lt;String, String&gt;&gt; variables) throws MtasParserException {
<span class="nc" id="L1118">    StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">    for (String split : splitList) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">      if (split.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L1121">        String[] subSplit = split.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (subSplit.length == 2) {</span>
<span class="nc" id="L1123">          String decodedVariableName = new String(dec.decode(subSplit[0]),</span>
              StandardCharsets.UTF_8);
<span class="nc" id="L1125">          String decodedVariableValue = new String(dec.decode(subSplit[1]),</span>
              StandardCharsets.UTF_8);
<span class="nc bnc" id="L1127" title="All 2 branches missed.">          if (variables.containsKey(decodedVariableName)) {</span>
<span class="nc" id="L1128">            if (variables.get(decodedVariableName)</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">                .containsKey(decodedVariableValue)) {</span>
<span class="nc" id="L1130">              String valueFromVariable = variables.get(decodedVariableName)</span>
<span class="nc" id="L1131">                  .get(decodedVariableValue);</span>
<span class="nc" id="L1132">              builder.append(valueFromVariable);</span>
<span class="nc" id="L1133">            } else {</span>
<span class="nc" id="L1134">              throw new MtasParserException(&quot;id &quot; + decodedVariableValue</span>
                  + &quot; not found in &quot; + decodedVariableName);
            }
          } else {
<span class="nc" id="L1138">            throw new MtasParserException(</span>
                &quot;variable &quot; + decodedVariableName + &quot; unknown&quot;);
          }
        }
<span class="nc" id="L1142">      } else {</span>
        try {
<span class="nc" id="L1144">          builder.append(new String(dec.decode(split), StandardCharsets.UTF_8));</span>
<span class="nc" id="L1145">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1146">          log.info(e);</span>
<span class="nc" id="L1147">        }</span>
      }
    }
<span class="nc" id="L1150">    return builder.toString();</span>
  }

  /**
   * Compute payload from mapping payload.
   *
   * @param object the object
   * @param mappingPayloads the mapping payloads
   * @param currentList the current list
   * @return the bytes ref
   * @throws MtasParserException the mtas parser exception
   */
  private BytesRef computePayloadFromMappingPayload(MtasParserObject object,
      List&lt;Map&lt;String, String&gt;&gt; mappingPayloads,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList)
      throws MtasParserException {
<span class="fc" id="L1166">    BytesRef payload = null;</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">    for (Map&lt;String, String&gt; mappingPayload : mappingPayloads) {</span>
<span class="fc" id="L1168">      if (mappingPayload.get(MAPPING_VALUE_SOURCE)</span>
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">          .equals(MtasParserMapping.SOURCE_STRING)) {</span>
<span class="nc" id="L1170">        if (mappingPayload.get(MAPPING_VALUE_TYPE)</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            .equals(MtasParserMapping.PARSER_TYPE_STRING)</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            &amp;&amp; mappingPayload.get(MAPPING_VALUE_TEXT) != null) {</span>
<span class="nc" id="L1173">          BytesRef subpayload = computeMaximumFilteredPayload(</span>
<span class="nc" id="L1174">              mappingPayload.get(MAPPING_VALUE_TEXT), payload, null);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">          payload = (subpayload != null) ? subpayload : payload;</span>
<span class="nc" id="L1176">        }</span>
        // from objects
      } else {
<span class="fc" id="L1179">        MtasParserObject[] checkObjects = computeObjectFromMappingValue(object,</span>
            mappingPayload, currentList);
        // do checks and updates
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">        if (checkObjects != null) {</span>
          // payload from attribute
<span class="fc" id="L1184">          if (mappingPayload.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L1185" title="1 of 2 branches missed.">              .equals(MtasParserMapping.PARSER_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L1186">            BytesRef subpayload = computeMaximumFilteredPayload(</span>
<span class="fc" id="L1187">                checkObjects[0].getAttribute(mappingPayload.get(&quot;name&quot;)),</span>
<span class="fc" id="L1188">                payload, mappingPayload.get(MAPPING_VALUE_FILTER));</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            payload = (subpayload != null) ? subpayload : payload;</span>
            // payload from text
<span class="pc" id="L1191">          } else if (mappingPayload.get(&quot;type&quot;)</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">              .equals(MtasParserMapping.PARSER_TYPE_TEXT)) {</span>
<span class="nc" id="L1193">            BytesRef subpayload = computeMaximumFilteredPayload(</span>
<span class="nc" id="L1194">                object.getText(), payload,</span>
<span class="nc" id="L1195">                mappingPayload.get(MAPPING_VALUE_FILTER));</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            payload = (subpayload != null) ? subpayload : payload;</span>
          }
        }
      }
<span class="fc" id="L1200">    }</span>
<span class="fc" id="L1201">    return payload;</span>
  }

  /**
   * Prevalidate object.
   *
   * @param object the object
   * @param currentList the current list
   * @return the boolean
   */
  Boolean prevalidateObject(MtasParserObject object,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList) {
<span class="fc" id="L1213">    MtasParserType objectType = object.getType();</span>
<span class="fc" id="L1214">    List&lt;MtasParserMapping&lt;?&gt;&gt; mappings = objectType.getItems();</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">    if (mappings.isEmpty()) {</span>
<span class="fc" id="L1216">      return true;</span>
    }
<span class="fc bfc" id="L1218" title="All 2 branches covered.">    for (MtasParserMapping&lt;?&gt; mapping : mappings) {</span>
      try {
<span class="fc" id="L1220">        precheckMappingConditions(object, mapping.getConditions(), currentList);</span>
<span class="fc" id="L1221">        return true;</span>
<span class="fc" id="L1222">      } catch (MtasParserException e) {</span>
<span class="fc" id="L1223">        log.debug(e);</span>
      }
<span class="fc" id="L1225">    }</span>
<span class="fc" id="L1226">    return false;</span>
  }

  /**
   * Precheck mapping conditions.
   *
   * @param object the object
   * @param mappingConditions the mapping conditions
   * @param currentList the current list
   * @throws MtasParserException the mtas parser exception
   */
  void precheckMappingConditions(MtasParserObject object,
      List&lt;Map&lt;String, String&gt;&gt; mappingConditions,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList)
      throws MtasParserException {
<span class="fc bfc" id="L1241" title="All 2 branches covered.">    for (Map&lt;String, String&gt; mappingCondition : mappingConditions) {</span>
      // condition existence ancestor
<span class="fc" id="L1243">      if (mappingCondition.get(&quot;type&quot;)</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">          .equals(MtasParserMapping.PARSER_TYPE_EXISTENCE)) {</span>
<span class="fc" id="L1245">        int number = 0;</span>
        try {
<span class="fc" id="L1247">          number = Integer.parseInt(mappingCondition.get(&quot;number&quot;));</span>
<span class="nc" id="L1248">        } catch (Exception e) {</span>
<span class="nc" id="L1249">          log.debug(e);</span>
<span class="fc" id="L1250">        }</span>
<span class="fc" id="L1251">        String type = computeTypeFromMappingSource(</span>
<span class="fc" id="L1252">            mappingCondition.get(MAPPING_VALUE_SOURCE));</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        if (number != currentList.get(type).size()) {</span>
<span class="fc" id="L1254">          throw new MtasParserException(</span>
              &quot;condition mapping is &quot; + number + &quot; ancestors of &quot; + type
<span class="fc" id="L1256">                  + &quot; (but &quot; + currentList.get(type).size() + &quot; found)&quot;);</span>
        }
        // condition unknown ancestors
<span class="fc" id="L1259">      } else if (mappingCondition.get(&quot;type&quot;)</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">          .equals(MtasParserMapping.PARSER_TYPE_UNKNOWN_ANCESTOR)) {</span>
<span class="fc" id="L1261">        int number = 0;</span>
        try {
<span class="fc" id="L1263">          number = Integer.parseInt(mappingCondition.get(&quot;number&quot;));</span>
<span class="nc" id="L1264">        } catch (Exception e) {</span>
<span class="nc" id="L1265">          log.debug(e);</span>
<span class="fc" id="L1266">        }</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        if (number != object.getUnknownAncestorNumber()) {</span>
<span class="fc" id="L1268">          throw new MtasParserException(</span>
              &quot;condition mapping is &quot; + number + &quot; unknown ancestors (but &quot;
<span class="fc" id="L1270">                  + object.getUnknownAncestorNumber() + &quot; found)&quot;);</span>
        }
<span class="fc" id="L1272">      } else {</span>
<span class="fc" id="L1273">        MtasParserObject[] checkObjects = computeObjectFromMappingValue(object,</span>
            mappingCondition, currentList);
<span class="fc" id="L1275">        Boolean notCondition = false;</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">        if (mappingCondition.get(&quot;not&quot;) != null) {</span>
<span class="fc" id="L1277">          notCondition = true;</span>
        }
        // do checks
<span class="fc bfc" id="L1280" title="All 2 branches covered.">        if (checkObjects != null) {</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">          checkObjectLoop: for (MtasParserObject checkObject : checkObjects) {</span>
<span class="fc" id="L1282">            MtasParserType checkType = checkObject.getType();</span>
            // condition on name
<span class="fc" id="L1284">            if (mappingCondition.get(&quot;type&quot;)</span>
<span class="fc bfc" id="L1285" title="All 2 branches covered.">                .equals(MtasParserMapping.PARSER_TYPE_NAME)) {</span>
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">              if (notCondition &amp;&amp; mappingCondition.get(MAPPING_VALUE_CONDITION)</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">                  .equals(checkType.getName())) {</span>
<span class="nc" id="L1288">                throw new MtasParserException(&quot;condition NOT &quot;</span>
<span class="nc" id="L1289">                    + mappingCondition.get(MAPPING_VALUE_CONDITION)</span>
<span class="nc" id="L1290">                    + &quot; on name not matched (is &quot; + checkType.getName() + &quot;)&quot;);</span>
<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">              } else if (!notCondition &amp;&amp; mappingCondition</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">                  .get(MAPPING_VALUE_CONDITION).equals(checkType.getName())) {</span>
<span class="fc" id="L1293">                break checkObjectLoop;</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">              } else if (!notCondition &amp;&amp; !mappingCondition</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                  .get(MAPPING_VALUE_CONDITION).equals(checkType.getName())) {</span>
<span class="nc" id="L1296">                throw new MtasParserException(&quot;condition &quot;</span>
<span class="nc" id="L1297">                    + mappingCondition.get(MAPPING_VALUE_CONDITION)</span>
<span class="nc" id="L1298">                    + &quot; on name not matched (is &quot; + checkType.getName() + &quot;)&quot;);</span>
              }
              // condition on attribute
<span class="fc" id="L1301">            } else if (mappingCondition.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">                .equals(MtasParserMapping.PARSER_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L1303">              String attributeCondition = mappingCondition</span>
<span class="fc" id="L1304">                  .get(MAPPING_VALUE_CONDITION);</span>
<span class="fc" id="L1305">              String namespace = mappingCondition.get(MAPPING_VALUE_NAMESPACE);</span>
              String attributeValue;
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">              if(namespace==null) {</span>
<span class="fc" id="L1308">                attributeValue = checkObject.getAttribute(mappingCondition.get(MAPPING_VALUE_NAME));</span>
              } else {
<span class="nc" id="L1310">                attributeValue = checkObject.getOtherAttribute(namespace, mappingCondition.get(MAPPING_VALUE_NAME));</span>
              }
<span class="pc bpc" id="L1312" title="1 of 4 branches missed.">              if ((attributeCondition == null) &amp;&amp; (attributeValue == null)) {</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">                if (!notCondition) {</span>
<span class="nc" id="L1314">                  throw new MtasParserException(&quot;attribute &quot;</span>
<span class="nc" id="L1315">                      + mappingCondition.get(&quot;name&quot;) + &quot; not available&quot;);</span>
                }
<span class="pc bpc" id="L1317" title="1 of 4 branches missed.">              } else if ((attributeCondition != null)</span>
                  &amp;&amp; (attributeValue == null)) {
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                if (!notCondition) {</span>
<span class="nc" id="L1320">                  throw new MtasParserException(</span>
                      &quot;condition &quot; + attributeCondition + &quot; on attribute &quot;
<span class="nc" id="L1322">                          + mappingCondition.get(&quot;name&quot;)</span>
                          + &quot; not matched (is null)&quot;);
                }
<span class="fc bfc" id="L1325" title="All 2 branches covered.">              } else if (attributeCondition != null) {</span>
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">                if (!notCondition</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                    &amp;&amp; !attributeCondition.equals(attributeValue)) {</span>
<span class="nc" id="L1328">                  throw new MtasParserException(</span>
                      &quot;condition &quot; + attributeCondition + &quot; on attribute &quot;
<span class="nc" id="L1330">                          + mappingCondition.get(&quot;name&quot;) + &quot; not matched (is &quot;</span>
                          + attributeValue + &quot;)&quot;);
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">                } else if (!notCondition</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                    &amp;&amp; attributeCondition.equals(attributeValue)) {</span>
<span class="nc" id="L1334">                  break checkObjectLoop;</span>
<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">                } else if (notCondition</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                    &amp;&amp; attributeCondition.equals(attributeValue)) {</span>
<span class="fc" id="L1337">                  throw new MtasParserException(</span>
                      &quot;condition NOT &quot; + attributeCondition + &quot; on attribute &quot;
<span class="fc" id="L1339">                          + mappingCondition.get(&quot;name&quot;) + &quot; not matched (is &quot;</span>
                          + attributeValue + &quot;)&quot;);
                }
              }
              // condition on text
<span class="pc" id="L1344">            } else if (mappingCondition.get(&quot;type&quot;)</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                .equals(MtasParserMapping.PARSER_TYPE_TEXT)</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                &amp;&amp; object.getType().precheckText()) {</span>
<span class="nc" id="L1347">              String textCondition = mappingCondition</span>
<span class="nc" id="L1348">                  .get(MAPPING_VALUE_CONDITION);</span>
<span class="nc" id="L1349">              String textValue = object.getText();</span>
<span class="nc bnc" id="L1350" title="All 4 branches missed.">              if ((textCondition == null)</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                  &amp;&amp; ((textValue == null) || textValue.equals(&quot;&quot;))) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                if (!notCondition) {</span>
<span class="nc" id="L1353">                  throw new MtasParserException(&quot;no text available&quot;);</span>
                }
<span class="nc bnc" id="L1355" title="All 4 branches missed.">              } else if ((textCondition != null) &amp;&amp; (textValue == null)) {</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                if (!notCondition) {</span>
<span class="nc" id="L1357">                  throw new MtasParserException(&quot;condition &quot; + textCondition</span>
                      + &quot; on text not matched (is null)&quot;);
                }
<span class="nc bnc" id="L1360" title="All 2 branches missed.">              } else if (textCondition != null) {</span>
<span class="nc bnc" id="L1361" title="All 4 branches missed.">                if (!notCondition &amp;&amp; !textCondition.equals(textValue)) {</span>
<span class="nc" id="L1362">                  throw new MtasParserException(&quot;condition &quot; + textCondition</span>
                      + &quot; on text not matched (is &quot; + textValue + &quot;)&quot;);
<span class="nc bnc" id="L1364" title="All 4 branches missed.">                } else if (notCondition &amp;&amp; textCondition.equals(textValue)) {</span>
<span class="nc" id="L1365">                  throw new MtasParserException(&quot;condition NOT &quot; + textCondition</span>
                      + &quot; on text not matched (is &quot; + textValue + &quot;)&quot;);
                }
              }
            }
          }
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">        } else if (!notCondition) {</span>
<span class="fc" id="L1372">          throw new MtasParserException(</span>
              &quot;no object found to match condition&quot; + mappingCondition);
        }
      }
<span class="fc" id="L1376">    }</span>
<span class="fc" id="L1377">  }</span>

  /**
   * Postcheck mapping conditions.
   *
   * @param object the object
   * @param mappingConditions the mapping conditions
   * @param currentList the current list
   * @throws MtasParserException the mtas parser exception
   */
  private void postcheckMappingConditions(MtasParserObject object,
      List&lt;Map&lt;String, String&gt;&gt; mappingConditions,
      Map&lt;String, List&lt;MtasParserObject&gt;&gt; currentList)
      throws MtasParserException {
<span class="fc" id="L1391">    precheckMappingConditions(object, mappingConditions, currentList);</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">    for (Map&lt;String, String&gt; mappingCondition : mappingConditions) {</span>
      // condition on text
<span class="fc" id="L1394">      if (mappingCondition.get(&quot;type&quot;)</span>
<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">          .equals(MtasParserMapping.PARSER_TYPE_TEXT)) {</span>
<span class="nc" id="L1396">        MtasParserObject[] checkObjects = computeObjectFromMappingValue(object,</span>
            mappingCondition, currentList);
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (checkObjects != null) {</span>
<span class="nc" id="L1399">          String textCondition = mappingCondition.get(MAPPING_VALUE_CONDITION);</span>
<span class="nc" id="L1400">          String textValue = object.getText();</span>
<span class="nc" id="L1401">          Boolean notCondition = false;</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">          if (mappingCondition.get(&quot;not&quot;) != null) {</span>
<span class="nc" id="L1403">            notCondition = true;</span>
          }
<span class="nc bnc" id="L1405" title="All 4 branches missed.">          if ((textCondition == null)</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">              &amp;&amp; ((textValue == null) || textValue.isEmpty())) {</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            if (!notCondition) {</span>
<span class="nc" id="L1408">              throw new MtasParserException(&quot;no text available&quot;);</span>
            }
<span class="nc bnc" id="L1410" title="All 4 branches missed.">          } else if ((textCondition != null) &amp;&amp; (textValue == null)) {</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">            if (!notCondition) {</span>
<span class="nc" id="L1412">              throw new MtasParserException(&quot;condition &quot; + textCondition</span>
                  + &quot; on text not matched (is null)&quot;);
            }
<span class="nc bnc" id="L1415" title="All 2 branches missed.">          } else if (textCondition != null) {</span>
<span class="nc bnc" id="L1416" title="All 4 branches missed.">            if (!notCondition &amp;&amp; !textCondition.equals(textValue)) {</span>
<span class="nc" id="L1417">              throw new MtasParserException(&quot;condition &quot; + textCondition</span>
                  + &quot; on text not matched (is &quot; + textValue + &quot;)&quot;);
<span class="nc bnc" id="L1419" title="All 4 branches missed.">            } else if (notCondition &amp;&amp; textCondition.equals(textValue)) {</span>
<span class="nc" id="L1420">              throw new MtasParserException(&quot;condition NOT &quot; + textCondition</span>
                  + &quot; on text not matched (is &quot; + textValue + &quot;)&quot;);
            }
          }
        }
      }
<span class="fc" id="L1426">    }</span>
<span class="fc" id="L1427">  }</span>

  /**
   * Compute filtered split values.
   *
   * @param values the values
   * @param filter the filter
   * @return the string[]
   * @throws MtasConfigException the mtas config exception
   */
  private String[] computeFilteredSplitValues(String[] values, String filter)
      throws MtasConfigException {
<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if (filter != null) {</span>
<span class="nc" id="L1440">      String[] filters = filter.split(&quot;,&quot;);</span>
<span class="nc" id="L1441">      boolean[] valuesFilter = new boolean[values.length];</span>
<span class="nc" id="L1442">      boolean doSplitFilter = false;</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">      for (String item : filters) {</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">        if (item.trim().matches(</span>
<span class="nc" id="L1445">            &quot;^&quot; + Pattern.quote(MAPPING_FILTER_SPLIT) + &quot;\\([0-9\\-]+\\)$&quot;)) {</span>
<span class="nc" id="L1446">          doSplitFilter = true;</span>
<span class="nc" id="L1447">          Pattern splitContent = Pattern</span>
<span class="nc" id="L1448">              .compile(&quot;^&quot; + Pattern.quote(MAPPING_FILTER_SPLIT)</span>
                  + &quot;\\(([0-9]+)(-([0-9]+))?\\)$&quot;);
<span class="nc" id="L1450">          Matcher splitContentMatcher = splitContent.matcher(item.trim());</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">          while (splitContentMatcher.find()) {</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (splitContentMatcher.group(3) == null) {</span>
<span class="nc" id="L1453">              int i = Integer.parseInt(splitContentMatcher.group(1));</span>
<span class="nc bnc" id="L1454" title="All 4 branches missed.">              if (i &gt;= 0 &amp;&amp; i &lt; values.length) {</span>
<span class="nc" id="L1455">                valuesFilter[i] = true;</span>
              }
<span class="nc" id="L1457">            } else {</span>
<span class="nc" id="L1458">              int i1 = Integer.parseInt(splitContentMatcher.group(1));</span>
<span class="nc" id="L1459">              int i2 = Integer.parseInt(splitContentMatcher.group(3));</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">              for (int i = Math.max(0, i1); i &lt; Math.min(values.length,</span>
<span class="nc" id="L1461">                  i2); i++) {</span>
<span class="nc" id="L1462">                valuesFilter[i] = true;</span>
              }
<span class="nc" id="L1464">            }</span>
          }
        }
      }
<span class="nc bnc" id="L1468" title="All 2 branches missed.">      if (doSplitFilter) {</span>
<span class="nc" id="L1469">        int number = 0;</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        for (int i = 0; i &lt; valuesFilter.length; i++) {</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">          if (valuesFilter[i]) {</span>
<span class="nc" id="L1472">            number++;</span>
          }
        }
<span class="nc bnc" id="L1475" title="All 2 branches missed.">        if (number &gt; 0) {</span>
<span class="nc" id="L1476">          String[] newValues = new String[number];</span>
<span class="nc" id="L1477">          number = 0;</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">          for (int i = 0; i &lt; valuesFilter.length; i++) {</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            if (valuesFilter[i]) {</span>
<span class="nc" id="L1480">              newValues[number] = values[i];</span>
<span class="nc" id="L1481">              number++;</span>
            }
          }
<span class="nc" id="L1484">          return newValues;</span>
        } else {
<span class="nc" id="L1486">          return new String[] {};</span>
        }
      }
    }
<span class="nc" id="L1490">    return values;</span>
  }

  /**
   * Compute filtered prefixed value.
   *
   * @param type the type
   * @param value the value
   * @param filter the filter
   * @param prefix the prefix
   * @return the string
   * @throws MtasConfigException the mtas config exception
   */
  private String computeFilteredPrefixedValue(String type, String value,
      String filter, String prefix) throws MtasConfigException {
<span class="fc" id="L1505">    String localValue = value;</span>
    // do magic with filter
<span class="fc bfc" id="L1507" title="All 2 branches covered.">    if (filter != null) {</span>
<span class="fc" id="L1508">      String[] filters = filter.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">      for (String item : filters) {</span>
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">        if (item.trim().equals(MAPPING_FILTER_UPPERCASE)) {</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">          localValue = localValue == null ? null : localValue.toUpperCase();</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        } else if (item.trim().equals(MAPPING_FILTER_LOWERCASE)) {</span>
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">          localValue = localValue == null ? null : localValue.toLowerCase();</span>
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">        } else if (item.trim().equals(MAPPING_FILTER_ASCII)) {</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">          if (localValue != null) {</span>
<span class="fc" id="L1516">            char[] old = localValue.toCharArray();</span>
<span class="fc" id="L1517">            char[] ascii = new char[4 * old.length];</span>
<span class="fc" id="L1518">            ASCIIFoldingFilter.foldToASCII(old, 0, ascii, 0,</span>
<span class="fc" id="L1519">                localValue.length());</span>
<span class="fc" id="L1520">            localValue = new String(ascii);</span>
<span class="fc" id="L1521">          }</span>
<span class="nc" id="L1522">        } else if (item.trim()</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">            .matches(Pattern.quote(MAPPING_FILTER_SPLIT) + &quot;\\([0-9\\-]+\\)&quot;)) {</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">          if (!type.equals(MtasParserMapping.PARSER_TYPE_TEXT_SPLIT)) {</span>
<span class="nc" id="L1525">            throw new MtasConfigException(</span>
                &quot;split filter not allowed for &quot; + type);
          }
        } else {
<span class="nc" id="L1529">          throw new MtasConfigException(</span>
              &quot;unknown filter &quot; + item + &quot; for value &quot; + localValue);
        }
      }
    }
<span class="fc bfc" id="L1534" title="All 4 branches covered.">    if (localValue != null &amp;&amp; prefix != null) {</span>
<span class="fc" id="L1535">      localValue = prefix + localValue;</span>
    }
<span class="fc" id="L1537">    return localValue;</span>
  }

  /**
   * Compute maximum filtered payload.
   *
   * @param value the value
   * @param payload the payload
   * @param filter the filter
   * @return the bytes ref
   */
  private BytesRef computeMaximumFilteredPayload(String value, BytesRef payload,
      String filter) {
    // do magic with filter
<span class="fc bfc" id="L1551" title="All 2 branches covered.">    if (value != null) {</span>
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">      if (payload != null) {</span>
<span class="nc" id="L1553">        Float payloadFloat = PayloadHelper.decodeFloat(payload.bytes,</span>
            payload.offset);
<span class="nc" id="L1555">        Float valueFloat = Float.parseFloat(value);</span>
<span class="nc" id="L1556">        return new BytesRef(</span>
<span class="nc" id="L1557">            PayloadHelper.encodeFloat(Math.max(payloadFloat, valueFloat)));</span>
      } else {
<span class="fc" id="L1559">        return new BytesRef(PayloadHelper.encodeFloat(Float.parseFloat(value)));</span>
      }
    } else {
<span class="fc" id="L1562">      return payload;</span>
    }
  }

  /**
   * The Class MtasParserType.
   *
   * @param &lt;T&gt; the generic type
   */
  protected static class MtasParserType&lt;T&gt; {

    /** The type. */
    private String type;

    /** The name. */
    private String name;

    /** The precheck text. */
    protected boolean precheckText;

    /** The ref attribute name. */
    private String refAttributeName;

    /** The items. */
<span class="fc" id="L1586">    protected ArrayList&lt;T&gt; items = new ArrayList&lt;&gt;();</span>

    /**
     * Instantiates a new mtas parser type.
     *
     * @param type the type
     * @param name the name
     * @param precheckText the precheck text
     */
<span class="fc" id="L1595">    MtasParserType(String type, String name, boolean precheckText) {</span>
<span class="fc" id="L1596">      this.type = type;</span>
<span class="fc" id="L1597">      this.name = name;</span>
<span class="fc" id="L1598">      this.precheckText = precheckText;</span>
<span class="fc" id="L1599">    }</span>

    /**
     * Instantiates a new mtas parser type.
     *
     * @param type the type
     * @param name the name
     * @param precheckText the precheck text
     * @param refAttributeName the ref attribute name
     */
    MtasParserType(String type, String name, boolean precheckText,
        String refAttributeName) {
<span class="fc" id="L1611">      this(type, name, precheckText);</span>
<span class="fc" id="L1612">      this.refAttributeName = refAttributeName;</span>
<span class="fc" id="L1613">    }</span>

    /**
     * Gets the ref attribute name.
     *
     * @return the ref attribute name
     */
    public String getRefAttributeName() {
<span class="fc" id="L1621">      return refAttributeName;</span>
    }

    /**
     * Gets the name.
     *
     * @return the name
     */
    public String getName() {
<span class="fc" id="L1630">      return name;</span>
    }

    /**
     * Gets the type.
     *
     * @return the type
     */
    public String getType() {
<span class="fc" id="L1639">      return type;</span>
    }

    /**
     * Precheck text.
     *
     * @return true, if successful
     */
    public boolean precheckText() {
<span class="nc" id="L1648">      return precheckText;</span>
    }

    /**
     * Adds the item.
     *
     * @param item the item
     */
    public void addItem(T item) {
<span class="fc" id="L1657">      items.add(item);</span>
<span class="fc" id="L1658">    }</span>

    /**
     * Gets the items.
     *
     * @return the items
     */
    public List&lt;T&gt; getItems() {
<span class="fc" id="L1666">      return items;</span>
    }

  }

  /**
   * The Class MtasParserVariableValue.
   */
  protected static class MtasParserVariableValue {

    /** The type. */
    public String type;

    /** The name. */
    public String name;

    /**
     * Instantiates a new mtas parser variable value.
     *
     * @param type the type
     * @param name the name
     */
<span class="nc" id="L1688">    public MtasParserVariableValue(String type, String name) {</span>
<span class="nc" id="L1689">      this.type = type;</span>
<span class="nc" id="L1690">      this.name = name;</span>
<span class="nc" id="L1691">    }</span>

  }

  /**
   * The Class MtasParserMappingToken.
   */
  protected static class MtasParserMappingToken {

    /** The type. */
    public String type;

    /** The offset. */
    public Boolean offset;

    /** The realoffset. */
    public Boolean realoffset;

    /** The parent. */
    public Boolean parent;

    /** The pre values. */
    public List&lt;Map&lt;String, String&gt;&gt; preValues;

    /** The post values. */
    public List&lt;Map&lt;String, String&gt;&gt; postValues;

    /** The payload. */
    public List&lt;Map&lt;String, String&gt;&gt; payload;

    /**
     * Instantiates a new mtas parser mapping token.
     *
     * @param tokenType the token type
     */
<span class="fc" id="L1726">    public MtasParserMappingToken(String tokenType) {</span>
<span class="fc" id="L1727">      type = tokenType;</span>
<span class="fc" id="L1728">      offset = true;</span>
<span class="fc" id="L1729">      realoffset = true;</span>
<span class="fc" id="L1730">      parent = true;</span>
<span class="fc" id="L1731">      preValues = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1732">      postValues = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1733">      payload = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1734">    }</span>

    /**
     * Sets the offset.
     *
     * @param tokenOffset the new offset
     */
    public void setOffset(Boolean tokenOffset) {
<span class="fc" id="L1742">      offset = tokenOffset;</span>
<span class="fc" id="L1743">    }</span>

    /**
     * Sets the real offset.
     *
     * @param tokenRealOffset the new real offset
     */
    public void setRealOffset(Boolean tokenRealOffset) {
<span class="fc" id="L1751">      realoffset = tokenRealOffset;</span>
<span class="fc" id="L1752">    }</span>

    /**
     * Sets the parent.
     *
     * @param tokenParent the new parent
     */
    public void setParent(Boolean tokenParent) {
<span class="fc" id="L1760">      parent = tokenParent;</span>
<span class="fc" id="L1761">    }</span>

  }

  /**
   * The Class MtasParserVariable.
   */
  protected static class MtasParserVariable {

    /** The name. */
    public String name;

    /** The variable. */
    public String variable;

    /** The values. */
    protected ArrayList&lt;MtasParserVariableValue&gt; values;

    /**
     * Instantiates a new mtas parser variable.
     *
     * @param name the name
     * @param value the value
     */
<span class="nc" id="L1785">    public MtasParserVariable(String name, String value) {</span>
<span class="nc" id="L1786">      this.name = name;</span>
<span class="nc" id="L1787">      this.variable = value;</span>
<span class="nc" id="L1788">      values = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1789">    }</span>

    /**
     * Process config.
     *
     * @param config the config
     * @throws MtasConfigException the mtas config exception
     */
    public void processConfig(MtasConfiguration config)
        throws MtasConfigException {
<span class="nc bnc" id="L1799" title="All 2 branches missed.">      for (int k = 0; k &lt; config.children.size(); k++) {</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        if (config.children.get(k).name.equals(VARIABLE_SUBTYPE_VALUE)) {</span>

<span class="nc bnc" id="L1802" title="All 2 branches missed.">          for (int m = 0; m &lt; config.children.get(k).children.size(); m++) {</span>
<span class="nc" id="L1803">            if (config.children.get(k).children.get(m).name</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                .equals(VARIABLE_SUBTYPE_VALUE_ITEM)) {</span>
<span class="nc" id="L1805">              String valueType = config.children.get(k).children</span>
<span class="nc" id="L1806">                  .get(m).attributes.get(&quot;type&quot;);</span>
<span class="nc" id="L1807">              String nameType = config.children.get(k).children</span>
<span class="nc" id="L1808">                  .get(m).attributes.get(&quot;name&quot;);</span>
<span class="nc bnc" id="L1809" title="All 6 branches missed.">              if ((valueType != null) &amp;&amp; valueType.equals(&quot;attribute&quot;)</span>
                  &amp;&amp; nameType != null) {
<span class="nc" id="L1811">                MtasParserVariableValue variableValue = new MtasParserVariableValue(</span>
                    valueType, nameType);
<span class="nc" id="L1813">                values.add(variableValue);</span>
              }
            }
          }
        } else {
<span class="nc" id="L1818">          throw new MtasConfigException(</span>
<span class="nc" id="L1819">              &quot;unknown variable subtype &quot; + config.children.get(k).name</span>
<span class="nc" id="L1820">                  + &quot; in variable &quot; + config.attributes.get(&quot;name&quot;));</span>
        }
      }
<span class="nc" id="L1823">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L1832">      StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L1833">      builder.append(&quot;variable &quot; + variable + &quot; from &quot; + name);</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">      for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="nc" id="L1835">        builder.append(&quot;\n\tvalue &quot; + i);</span>
<span class="nc" id="L1836">        builder.append(&quot; - &quot; + values.get(i).type);</span>
      }
<span class="nc" id="L1838">      return builder.toString();</span>
    }
  }

  /**
   * The Class MtasParserMapping.
   *
   * @param &lt;T&gt; the generic type
   */
  protected abstract class MtasParserMapping&lt;T extends MtasParserMapping&lt;T&gt;&gt; {

    /**
     * Self.
     *
     * @return the t
     */
    protected abstract T self();

    /** The Constant SOURCE_OWN. */
    protected static final String SOURCE_OWN = &quot;own&quot;;

    /** The Constant SOURCE_REFS. */
    protected static final String SOURCE_REFS = &quot;refs&quot;;

    /** The Constant SOURCE_ANCESTOR_GROUP. */
    protected static final String SOURCE_ANCESTOR_GROUP = &quot;ancestorGroup&quot;;

    /** The Constant SOURCE_ANCESTOR_GROUP_ANNOTATION. */
    protected static final String SOURCE_ANCESTOR_GROUP_ANNOTATION = &quot;ancestorGroupAnnotation&quot;;

    /** The Constant SOURCE_ANCESTOR_WORD. */
    protected static final String SOURCE_ANCESTOR_WORD = &quot;ancestorWord&quot;;

    /** The Constant SOURCE_ANCESTOR_WORD_ANNOTATION. */
    protected static final String SOURCE_ANCESTOR_WORD_ANNOTATION = &quot;ancestorWordAnnotation&quot;;

    /** The Constant SOURCE_ANCESTOR_RELATION. */
    protected static final String SOURCE_ANCESTOR_RELATION = &quot;ancestorRelation&quot;;

    /** The Constant SOURCE_ANCESTOR_RELATION_ANNOTATION. */
    protected static final String SOURCE_ANCESTOR_RELATION_ANNOTATION = &quot;ancestorRelationAnnotation&quot;;

    /** The Constant SOURCE_STRING. */
    protected static final String SOURCE_STRING = &quot;string&quot;;

    /** The Constant PARSER_TYPE_VARIABLE. */
    protected static final String PARSER_TYPE_VARIABLE = &quot;variable&quot;;

    /** The Constant PARSER_TYPE_STRING. */
    protected static final String PARSER_TYPE_STRING = &quot;string&quot;;

    /** The Constant PARSER_TYPE_NAME. */
    protected static final String PARSER_TYPE_NAME = &quot;name&quot;;

    /** The Constant PARSER_TYPE_ATTRIBUTE. */
    protected static final String PARSER_TYPE_ATTRIBUTE = &quot;attribute&quot;;

    /** The Constant PARSER_TYPE_TEXT. */
    protected static final String PARSER_TYPE_TEXT = &quot;text&quot;;

    /** The Constant PARSER_TYPE_TEXT_SPLIT. */
    protected static final String PARSER_TYPE_TEXT_SPLIT = &quot;textSplit&quot;;

    /** The Constant PARSER_TYPE_EXISTENCE. */
    protected static final String PARSER_TYPE_EXISTENCE = &quot;existence&quot;;

    /** The Constant PARSER_TYPE_UNKNOWN_ANCESTOR. */
    protected static final String PARSER_TYPE_UNKNOWN_ANCESTOR = &quot;unknownAncestor&quot;;

    /** The type. */
    protected String type;

    /** The offset. */
    protected String offset;

    /** The real offset. */
    protected String realOffset;

    /** The position. */
    protected String position;

    /** The start. */
    protected String start;

    /** The end. */
    protected String end;

    /** The tokens. */
    protected List&lt;MtasParserMappingToken&gt; tokens;

    /** The conditions. */
    protected List&lt;Map&lt;String, String&gt;&gt; conditions;

    /**
     * Instantiates a new mtas parser mapping.
     */
<span class="fc" id="L1934">    public MtasParserMapping() {</span>
<span class="fc" id="L1935">      type = null;</span>
<span class="fc" id="L1936">      offset = null;</span>
<span class="fc" id="L1937">      realOffset = null;</span>
<span class="fc" id="L1938">      position = null;</span>
<span class="fc" id="L1939">      tokens = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1940">      conditions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1941">      start = null;</span>
<span class="fc" id="L1942">      end = null;</span>
<span class="fc" id="L1943">    }</span>

    /**
     * Process config.
     *
     * @param config the config
     * @throws MtasConfigException the mtas config exception
     */
    public void processConfig(MtasConfiguration config)
        throws MtasConfigException {
<span class="fc" id="L1953">      setStartEnd(config.attributes.get(&quot;start&quot;), config.attributes.get(&quot;end&quot;));</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">      for (int k = 0; k &lt; config.children.size(); k++) {</span>
<span class="fc bfc" id="L1955" title="All 2 branches covered.">        if (config.children.get(k).name.equals(MAPPING_SUBTYPE_TOKEN)) {</span>
<span class="fc" id="L1956">          String tokenType = config.children.get(k).attributes.get(&quot;type&quot;);</span>
<span class="pc bpc" id="L1957" title="2 of 4 branches missed.">          if ((tokenType != null) &amp;&amp; tokenType.equals(&quot;string&quot;)) {</span>
<span class="fc" id="L1958">            MtasParserMappingToken mappingToken = new MtasParserMappingToken(</span>
                tokenType);
<span class="fc" id="L1960">            tokens.add(mappingToken);</span>
            // check attributes
<span class="fc bfc" id="L1962" title="All 2 branches covered.">            for (String tokenAttributeName : config.children.get(k).attributes</span>
<span class="fc" id="L1963">                .keySet()) {</span>
<span class="fc" id="L1964">              String attributeValue = config.children.get(k).attributes</span>
<span class="fc" id="L1965">                  .get(tokenAttributeName);</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">              if (tokenAttributeName.equals(TOKEN_OFFSET)) {</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">                if (!attributeValue.equals(&quot;true&quot;)</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">                    &amp;&amp; !attributeValue.equals(&quot;1&quot;)) {</span>
<span class="fc" id="L1969">                  mappingToken.setOffset(false);</span>
                } else {
<span class="nc" id="L1971">                  mappingToken.setOffset(true);</span>
                }
<span class="fc bfc" id="L1973" title="All 2 branches covered.">              } else if (tokenAttributeName.equals(TOKEN_REALOFFSET)) {</span>
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">                if (!attributeValue.equals(&quot;true&quot;)</span>
<span class="pc bpc" id="L1975" title="1 of 2 branches missed.">                    &amp;&amp; !attributeValue.equals(&quot;1&quot;)) {</span>
<span class="fc" id="L1976">                  mappingToken.setRealOffset(false);</span>
                } else {
<span class="nc" id="L1978">                  mappingToken.setRealOffset(true);</span>
                }
<span class="fc bfc" id="L1980" title="All 2 branches covered.">              } else if (tokenAttributeName.equals(TOKEN_PARENT)) {</span>
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">                if (!attributeValue.equals(&quot;true&quot;)</span>
<span class="pc bpc" id="L1982" title="1 of 2 branches missed.">                    &amp;&amp; !attributeValue.equals(&quot;1&quot;)) {</span>
<span class="fc" id="L1983">                  mappingToken.setParent(false);</span>
                } else {
<span class="nc" id="L1985">                  mappingToken.setParent(true);</span>
                }
              }
<span class="fc" id="L1988">            }</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">            for (int m = 0; m &lt; config.children.get(k).children.size(); m++) {</span>
<span class="fc" id="L1990">              if (config.children.get(k).children.get(m).name</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">                  .equals(MAPPING_SUBTYPE_TOKEN_PRE)</span>
<span class="fc" id="L1992">                  || config.children.get(k).children.get(m).name</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">                      .equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="fc" id="L1994">                MtasConfiguration items = config.children.get(k).children</span>
<span class="fc" id="L1995">                    .get(m);</span>
<span class="fc bfc" id="L1996" title="All 2 branches covered.">                for (int l = 0; l &lt; items.children.size(); l++) {</span>
<span class="pc bpc" id="L1997" title="1 of 2 branches missed.">                  if (items.children.get(l).name.equals(&quot;item&quot;)) {</span>
<span class="fc" id="L1998">                    String itemType = items.children.get(l).attributes</span>
<span class="fc" id="L1999">                        .get(MAPPING_VALUE_TYPE);</span>
<span class="fc" id="L2000">                    String nameAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2001">                        .get(MAPPING_VALUE_NAME);</span>
<span class="fc" id="L2002">                    String namespaceAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2003">                        .get(MAPPING_VALUE_NAMESPACE);</span>
<span class="fc" id="L2004">                    String prefixAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2005">                        .get(MAPPING_VALUE_PREFIX);</span>
<span class="fc" id="L2006">                    String filterAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2007">                        .get(MAPPING_VALUE_FILTER);</span>
<span class="fc" id="L2008">                    String distanceAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2009">                        .get(MAPPING_VALUE_DISTANCE);</span>
<span class="fc" id="L2010">                    String valueAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2011">                        .get(MAPPING_VALUE_VALUE);</span>
<span class="fc bfc" id="L2012" title="All 2 branches covered.">                    if (itemType.equals(ITEM_TYPE_STRING)) {</span>
<span class="fc" id="L2013">                      addString(mappingToken, items.name, valueAttribute);</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">                    } else if (itemType.equals(ITEM_TYPE_NAME)) {</span>
<span class="fc" id="L2015">                      addName(mappingToken, items.name, prefixAttribute,</span>
                          filterAttribute);
<span class="fc bfc" id="L2017" title="All 2 branches covered.">                    } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L2018">                      addAttribute(mappingToken, items.name, nameAttribute, namespaceAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="fc bfc" id="L2020" title="All 2 branches covered.">                    } else if (itemType.equals(ITEM_TYPE_TEXT)) {</span>
<span class="fc" id="L2021">                      addText(mappingToken, items.name, prefixAttribute,</span>
                          filterAttribute);
<span class="pc bpc" id="L2023" title="1 of 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_TEXT_SPLIT)) {</span>
<span class="nc" id="L2024">                      addTextSplit(mappingToken, items.name, valueAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="pc bpc" id="L2026" title="1 of 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR)) {</span>
<span class="fc" id="L2027">                      addAncestorName(computeAncestorSourceType(type),</span>
                          mappingToken, items.name,
<span class="fc" id="L2029">                          computeDistance(distanceAttribute), prefixAttribute,</span>
                          filterAttribute);
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2032">                      addAncestorName(SOURCE_ANCESTOR_GROUP, mappingToken,</span>
<span class="nc" id="L2033">                          items.name, computeDistance(distanceAttribute),</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2035">                    } else if (itemType</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                        .equals(ITEM_TYPE_NAME_ANCESTOR_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L2037">                      addAncestorName(SOURCE_ANCESTOR_GROUP_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2039">                          computeDistance(distanceAttribute), prefixAttribute,</span>
                          filterAttribute);
<span class="nc bnc" id="L2041" title="All 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR_WORD)) {</span>
<span class="nc" id="L2042">                      addAncestorName(SOURCE_ANCESTOR_WORD, mappingToken,</span>
<span class="nc" id="L2043">                          items.name, computeDistance(distanceAttribute),</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2045">                    } else if (itemType</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">                        .equals(ITEM_TYPE_NAME_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2047">                      addAncestorName(SOURCE_ANCESTOR_WORD_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2049">                          computeDistance(distanceAttribute), prefixAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2051">                    } else if (itemType</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">                        .equals(ITEM_TYPE_NAME_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2053">                      addAncestorName(SOURCE_ANCESTOR_RELATION, mappingToken,</span>
<span class="nc" id="L2054">                          items.name, computeDistance(distanceAttribute),</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2056">                    } else if (itemType</span>
<span class="nc bnc" id="L2057" title="All 2 branches missed.">                        .equals(ITEM_TYPE_NAME_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2058">                      addAncestorName(SOURCE_ANCESTOR_RELATION_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2060">                          computeDistance(distanceAttribute), prefixAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2062">                    } else if (itemType</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2064">                      addAncestorAttribute(SOURCE_ANCESTOR_GROUP, mappingToken,</span>
<span class="nc" id="L2065">                          items.name, computeDistance(distanceAttribute),</span>
                          nameAttribute, prefixAttribute, filterAttribute);
<span class="nc bnc" id="L2067" title="All 2 branches missed.">                    } else if (itemType.equals(</span>
                        ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP_ANNOTATION)) {
<span class="nc" id="L2069">                      addAncestorAttribute(SOURCE_ANCESTOR_GROUP_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2071">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2073">                    } else if (itemType</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD)) {</span>
<span class="nc" id="L2075">                      addAncestorAttribute(SOURCE_ANCESTOR_WORD, mappingToken,</span>
<span class="nc" id="L2076">                          items.name, computeDistance(distanceAttribute),</span>
                          nameAttribute, prefixAttribute, filterAttribute);
<span class="nc" id="L2078">                    } else if (itemType</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2080">                      addAncestorAttribute(SOURCE_ANCESTOR_WORD_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2082">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2084">                    } else if (itemType</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2086">                      addAncestorAttribute(SOURCE_ANCESTOR_RELATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2088">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="nc bnc" id="L2090" title="All 2 branches missed.">                    } else if (itemType.equals(</span>
                        ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION_ANNOTATION)) {
<span class="nc" id="L2092">                      addAncestorAttribute(SOURCE_ANCESTOR_RELATION_ANNOTATION,</span>
                          mappingToken, items.name,
<span class="nc" id="L2094">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR)) {</span>
<span class="nc" id="L2097">                      addAncestorAttribute(computeAncestorSourceType(this.type),</span>
                          mappingToken, items.name,
<span class="nc" id="L2099">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          prefixAttribute, filterAttribute);
<span class="nc" id="L2101">                    } else if (itemType</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">                        .equals(ITEM_TYPE_VARIABLE_FROM_ATTRIBUTE)) {</span>
<span class="nc" id="L2103">                      addVariableFromAttribute(mappingToken, items.name,</span>
                          nameAttribute, prefixAttribute, valueAttribute);
                    } else {
<span class="nc" id="L2106">                      throw new MtasConfigException(String.format(</span>
                          &quot;unknown itemType %s for %s in mapping %s&quot;, itemType,
<span class="nc" id="L2108">                          items.name, config.attributes.get(&quot;name&quot;)));</span>
                    }
                  }
                }
<span class="fc" id="L2112">              } else if (config.children.get(k).children.get(m).name</span>
<span class="pc bpc" id="L2113" title="1 of 2 branches missed.">                  .equals(MAPPING_SUBTYPE_PAYLOAD)) {</span>
<span class="fc" id="L2114">                MtasConfiguration items = config.children.get(k).children</span>
<span class="fc" id="L2115">                    .get(m);</span>
<span class="fc bfc" id="L2116" title="All 2 branches covered.">                for (int l = 0; l &lt; items.children.size(); l++) {</span>
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">                  if (items.children.get(l).name.equals(&quot;item&quot;)) {</span>
<span class="fc" id="L2118">                    String itemType = items.children.get(l).attributes</span>
<span class="fc" id="L2119">                        .get(&quot;type&quot;);</span>
<span class="fc" id="L2120">                    String valueAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2121">                        .get(MAPPING_VALUE_VALUE);</span>
<span class="fc" id="L2122">                    String nameAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2123">                        .get(MAPPING_VALUE_NAME);</span>
<span class="fc" id="L2124">                    String filterAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2125">                        .get(MAPPING_VALUE_FILTER);</span>
<span class="fc" id="L2126">                    String distanceAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2127">                        .get(MAPPING_VALUE_DISTANCE);</span>
<span class="pc bpc" id="L2128" title="1 of 2 branches missed.">                    if (itemType.equals(ITEM_TYPE_STRING)) {</span>
<span class="nc" id="L2129">                      payloadString(mappingToken, valueAttribute);</span>
<span class="pc bpc" id="L2130" title="1 of 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_TEXT)) {</span>
<span class="nc" id="L2131">                      payloadText(mappingToken, filterAttribute);</span>
<span class="fc bfc" id="L2132" title="All 2 branches covered.">                    } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L2133">                      payloadAttribute(mappingToken, nameAttribute,</span>
                          filterAttribute);
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">                    } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR)) {</span>
<span class="fc" id="L2136">                      payloadAncestorAttribute(mappingToken,</span>
<span class="fc" id="L2137">                          computeAncestorSourceType(type),</span>
<span class="fc" id="L2138">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2140">                    } else if (itemType</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2142">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_GROUP,
<span class="nc" id="L2144">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc bnc" id="L2146" title="All 2 branches missed.">                    } else if (itemType.equals(</span>
                        ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP_ANNOTATION)) {
<span class="nc" id="L2148">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_GROUP_ANNOTATION,
<span class="nc" id="L2150">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2152">                    } else if (itemType</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD)) {</span>
<span class="nc" id="L2154">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_WORD,
<span class="nc" id="L2156">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2158">                    } else if (itemType</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2160">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_WORD_ANNOTATION,
<span class="nc" id="L2162">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc" id="L2164">                    } else if (itemType</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">                        .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2166">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_RELATION,
<span class="nc" id="L2168">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
<span class="nc bnc" id="L2170" title="All 2 branches missed.">                    } else if (itemType.equals(</span>
                        ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION_ANNOTATION)) {
<span class="nc" id="L2172">                      payloadAncestorAttribute(mappingToken,</span>
                          SOURCE_ANCESTOR_RELATION_ANNOTATION,
<span class="nc" id="L2174">                          computeDistance(distanceAttribute), nameAttribute,</span>
                          filterAttribute);
                    } else {
<span class="nc" id="L2177">                      throw new MtasConfigException(String.format(</span>
                          &quot;unknown itemType %s for %s in mapping %s&quot;, itemType,
<span class="nc" id="L2179">                          items.name, config.attributes.get(&quot;name&quot;)));</span>
                    }
                  }
                }
              }
            }
          }
<span class="fc" id="L2186">        } else if (config.children.get(k).name</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">            .equals(MAPPING_SUBTYPE_CONDITION)) {</span>
<span class="fc" id="L2188">          MtasConfiguration items = config.children.get(k);</span>
<span class="fc bfc" id="L2189" title="All 2 branches covered.">          for (int l = 0; l &lt; items.children.size(); l++) {</span>
<span class="pc bpc" id="L2190" title="1 of 2 branches missed.">            if (items.children.get(l).name.equals(&quot;item&quot;)) {</span>
<span class="fc" id="L2191">              String itemType = items.children.get(l).attributes.get(&quot;type&quot;);</span>
<span class="fc" id="L2192">              String nameAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2193">                  .get(MAPPING_VALUE_NAME);</span>
<span class="fc" id="L2194">              String namespaceAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2195">                  .get(MAPPING_VALUE_NAMESPACE);</span>
<span class="fc" id="L2196">              String conditionAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2197">                  .get(MAPPING_VALUE_CONDITION);</span>
<span class="fc" id="L2198">              String filterAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2199">                  .get(MAPPING_VALUE_FILTER);</span>
<span class="fc" id="L2200">              String numberAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2201">                  .get(MAPPING_VALUE_NUMBER);</span>
<span class="fc" id="L2202">              String distanceAttribute = items.children.get(l).attributes</span>
<span class="fc" id="L2203">                  .get(MAPPING_VALUE_DISTANCE);</span>
<span class="fc" id="L2204">              String notAttribute = items.children.get(l).attributes.get(&quot;not&quot;);</span>
<span class="pc bpc" id="L2205" title="1 of 4 branches missed.">              if ((notAttribute != null) &amp;&amp; !notAttribute.equals(&quot;true&quot;)</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">                  &amp;&amp; !notAttribute.equals(&quot;1&quot;)) {</span>
<span class="nc" id="L2207">                notAttribute = null;</span>
              }
<span class="fc bfc" id="L2209" title="All 2 branches covered.">              if (itemType.equals(ITEM_TYPE_ATTRIBUTE)) {</span>
<span class="fc" id="L2210">                conditionAttribute(nameAttribute, namespaceAttribute, conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_NAME)) {</span>
<span class="nc" id="L2213">                conditionName(conditionAttribute, notAttribute);</span>
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_TEXT)) {</span>
<span class="nc" id="L2215">                conditionText(conditionAttribute, filterAttribute,</span>
                    notAttribute);
<span class="fc bfc" id="L2217" title="All 2 branches covered.">              } else if (itemType.equals(ITEM_TYPE_UNKNOWN_ANCESTOR)) {</span>
<span class="fc" id="L2218">                conditionUnknownAncestor(computeNumber(numberAttribute));</span>
<span class="fc bfc" id="L2219" title="All 2 branches covered.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR)) {</span>
<span class="fc" id="L2220">                conditionAncestor(computeAncestorSourceType(type),</span>
<span class="fc" id="L2221">                    computeNumber(numberAttribute));</span>
<span class="pc bpc" id="L2222" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2223">                conditionAncestor(SOURCE_ANCESTOR_GROUP,</span>
<span class="nc" id="L2224">                    computeNumber(numberAttribute));</span>
<span class="pc bpc" id="L2225" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L2226">                conditionAncestor(SOURCE_ANCESTOR_GROUP_ANNOTATION,</span>
<span class="nc" id="L2227">                    computeNumber(numberAttribute));</span>
<span class="fc bfc" id="L2228" title="All 2 branches covered.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR_WORD)) {</span>
<span class="fc" id="L2229">                conditionAncestor(SOURCE_ANCESTOR_WORD,</span>
<span class="fc" id="L2230">                    computeNumber(numberAttribute));</span>
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2232">                conditionAncestor(SOURCE_ANCESTOR_WORD_ANNOTATION,</span>
<span class="nc" id="L2233">                    computeNumber(numberAttribute));</span>
<span class="pc bpc" id="L2234" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2235">                conditionAncestor(SOURCE_ANCESTOR_RELATION,</span>
<span class="nc" id="L2236">                    computeNumber(numberAttribute));</span>
<span class="fc" id="L2237">              } else if (itemType</span>
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">                  .equals(ITEM_TYPE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2239">                conditionAncestor(SOURCE_ANCESTOR_RELATION_ANNOTATION,</span>
<span class="nc" id="L2240">                    computeNumber(numberAttribute));</span>
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR)) {</span>
<span class="nc" id="L2242">                conditionAncestorAttribute(computeAncestorSourceType(type),</span>
<span class="nc" id="L2243">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="pc bpc" id="L2245" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2246">                conditionAncestorAttribute(SOURCE_ANCESTOR_GROUP,</span>
<span class="nc" id="L2247">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="fc" id="L2249">              } else if (itemType</span>
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">                  .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L2251">                conditionAncestorAttribute(SOURCE_ANCESTOR_GROUP_ANNOTATION,</span>
<span class="nc" id="L2252">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="pc bpc" id="L2254" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD)) {</span>
<span class="nc" id="L2255">                conditionAncestorAttribute(SOURCE_ANCESTOR_WORD,</span>
<span class="nc" id="L2256">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="fc" id="L2258">              } else if (itemType</span>
<span class="pc bpc" id="L2259" title="1 of 2 branches missed.">                  .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2260">                conditionAncestorAttribute(SOURCE_ANCESTOR_WORD_ANNOTATION,</span>
<span class="nc" id="L2261">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="fc" id="L2263">              } else if (itemType</span>
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">                  .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2265">                conditionAncestorAttribute(SOURCE_ANCESTOR_RELATION,</span>
<span class="nc" id="L2266">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="fc" id="L2268">              } else if (itemType</span>
<span class="pc bpc" id="L2269" title="1 of 2 branches missed.">                  .equals(ITEM_TYPE_ATTRIBUTE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2270">                conditionAncestorAttribute(SOURCE_ANCESTOR_RELATION_ANNOTATION,</span>
<span class="nc" id="L2271">                    computeDistance(distanceAttribute), nameAttribute,</span>
                    conditionAttribute, filterAttribute, notAttribute);
<span class="pc bpc" id="L2273" title="1 of 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR)) {</span>
<span class="fc" id="L2274">                conditionAncestorName(computeAncestorSourceType(type),</span>
<span class="fc" id="L2275">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc bnc" id="L2277" title="All 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR_GROUP)) {</span>
<span class="nc" id="L2278">                conditionAncestorName(SOURCE_ANCESTOR_GROUP,</span>
<span class="nc" id="L2279">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc" id="L2281">              } else if (itemType</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">                  .equals(ITEM_TYPE_NAME_ANCESTOR_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L2283">                conditionAncestorName(SOURCE_ANCESTOR_GROUP_ANNOTATION,</span>
<span class="nc" id="L2284">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc bnc" id="L2286" title="All 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR_WORD)) {</span>
<span class="nc" id="L2287">                conditionAncestorName(SOURCE_ANCESTOR_WORD,</span>
<span class="nc" id="L2288">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc" id="L2290">              } else if (itemType</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">                  .equals(ITEM_TYPE_NAME_ANCESTOR_WORD_ANNOTATION)) {</span>
<span class="nc" id="L2292">                conditionAncestorName(SOURCE_ANCESTOR_WORD_ANNOTATION,</span>
<span class="nc" id="L2293">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc bnc" id="L2295" title="All 2 branches missed.">              } else if (itemType.equals(ITEM_TYPE_NAME_ANCESTOR_RELATION)) {</span>
<span class="nc" id="L2296">                conditionAncestorName(SOURCE_ANCESTOR_RELATION,</span>
<span class="nc" id="L2297">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
<span class="nc" id="L2299">              } else if (itemType</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">                  .equals(ITEM_TYPE_NAME_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2301">                conditionAncestorName(SOURCE_ANCESTOR_RELATION_ANNOTATION,</span>
<span class="nc" id="L2302">                    computeDistance(distanceAttribute), conditionAttribute,</span>
                    filterAttribute, notAttribute);
              } else {
<span class="nc" id="L2305">                throw new MtasConfigException(</span>
<span class="nc" id="L2306">                    String.format(&quot;unknown itemType %s for %s in mapping %s&quot;,</span>
<span class="nc" id="L2307">                        itemType, config.children.get(k).name,</span>
<span class="nc" id="L2308">                        config.attributes.get(&quot;name&quot;)));</span>
              }
            }
          }
<span class="fc" id="L2312">        } else {</span>
<span class="nc" id="L2313">          throw new MtasConfigException(</span>
<span class="nc" id="L2314">              String.format(&quot;unknown mapping subType %s in mapping %s&quot;,</span>
<span class="nc" id="L2315">                  config.children.get(k).name, config.attributes.get(&quot;name&quot;)));</span>
        }
      }
<span class="fc" id="L2318">    }</span>

    /**
     * Sets the start end.
     *
     * @param start the start
     * @param end the end
     */
    protected void setStartEnd(String start, String end) {
<span class="pc bpc" id="L2327" title="7 of 8 branches missed.">      if (start != null &amp;&amp; !start.isEmpty() &amp;&amp; end != null &amp;&amp; !end.isEmpty()) {</span>
<span class="nc" id="L2328">        this.start = start;</span>
<span class="nc" id="L2329">        this.end = end;</span>
      }
<span class="fc" id="L2331">    }</span>

    /**
     * Condition unknown ancestor.
     *
     * @param number the number
     */
    private void conditionUnknownAncestor(String number) {
<span class="fc" id="L2339">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2340">      mapConstructionItem.put(&quot;type&quot;, PARSER_TYPE_UNKNOWN_ANCESTOR);</span>
<span class="fc" id="L2341">      mapConstructionItem.put(&quot;number&quot;, number);</span>
<span class="fc" id="L2342">      conditions.add(mapConstructionItem);</span>
<span class="fc" id="L2343">    }</span>

    /**
     * Adds the string.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param text the text
     */
    private void addString(MtasParserMappingToken mappingToken, String type,
        String text) {
<span class="fc" id="L2354">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2355">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_STRING);</span>
<span class="fc" id="L2356">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_STRING);</span>
<span class="fc" id="L2357">      mapConstructionItem.put(MAPPING_VALUE_TEXT, text);</span>
<span class="pc bpc" id="L2358" title="1 of 2 branches missed.">      if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="fc" id="L2359">        mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2360" title="All 2 branches missed.">      } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2361">        mappingToken.postValues.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2363">    }</span>

    /**
     * Payload string.
     *
     * @param mappingToken the mapping token
     * @param text the text
     */
    private void payloadString(MtasParserMappingToken mappingToken,
        String text) {
<span class="nc" id="L2373">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2374">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_STRING);</span>
<span class="nc" id="L2375">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_STRING);</span>
<span class="nc" id="L2376">      mapConstructionItem.put(MAPPING_VALUE_TEXT, text);</span>
<span class="nc" id="L2377">      mappingToken.payload.add(mapConstructionItem);</span>
<span class="nc" id="L2378">    }</span>

    /**
     * Adds the name.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param prefix the prefix
     * @param filter the filter
     */
    private void addName(MtasParserMappingToken mappingToken, String type,
        String prefix, String filter) {
<span class="fc" id="L2390">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2391">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="fc" id="L2392">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_NAME);</span>
<span class="fc" id="L2393">      mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="fc" id="L2394">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="pc bpc" id="L2395" title="1 of 2 branches missed.">      if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="fc" id="L2396">        mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">      } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2398">        mappingToken.postValues.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2400">    }</span>

    /**
     * Condition name.
     *
     * @param condition the condition
     * @param not the not
     */
    private void conditionName(String condition, String not) {
<span class="nc" id="L2409">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2410">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="nc" id="L2411">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_NAME);</span>
<span class="nc" id="L2412">      mapConstructionItem.put(MAPPING_VALUE_CONDITION, condition);</span>
<span class="nc" id="L2413">      mapConstructionItem.put(MAPPING_VALUE_NOT, not);</span>
<span class="nc" id="L2414">      conditions.add(mapConstructionItem);</span>
<span class="nc" id="L2415">    }</span>

    /**
     * Adds the text.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param prefix the prefix
     * @param filter the filter
     */
    private void addText(MtasParserMappingToken mappingToken, String type,
        String prefix, String filter) {
<span class="fc" id="L2427">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2428">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="fc" id="L2429">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_TEXT);</span>
<span class="fc" id="L2430">      mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="fc" id="L2431">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="pc bpc" id="L2432" title="1 of 2 branches missed.">      if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="nc" id="L2433">        mappingToken.preValues.add(mapConstructionItem);</span>
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">      } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="fc" id="L2435">        mappingToken.postValues.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2437">    }</span>

    /**
     * Adds the text split.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param split the split
     * @param prefix the prefix
     * @param filter the filter
     */
    private void addTextSplit(MtasParserMappingToken mappingToken, String type,
        String split, String prefix, String filter) {
<span class="nc" id="L2450">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2451">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="nc" id="L2452">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_TEXT_SPLIT);</span>
<span class="nc" id="L2453">      mapConstructionItem.put(MAPPING_VALUE_SPLIT, split);</span>
<span class="nc" id="L2454">      mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="nc" id="L2455">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="nc bnc" id="L2456" title="All 2 branches missed.">      if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="nc" id="L2457">        mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2458" title="All 2 branches missed.">      } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2459">        mappingToken.postValues.add(mapConstructionItem);</span>
      }
<span class="nc" id="L2461">    }</span>

    /**
     * Condition text.
     *
     * @param condition the condition
     * @param filter the filter
     * @param not the not
     */
    private void conditionText(String condition, String filter, String not) {
<span class="nc" id="L2471">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2472">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="nc" id="L2473">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_TEXT);</span>
<span class="nc" id="L2474">      mapConstructionItem.put(MAPPING_VALUE_CONDITION, condition);</span>
<span class="nc" id="L2475">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="nc" id="L2476">      mapConstructionItem.put(MAPPING_VALUE_NOT, not);</span>
<span class="nc" id="L2477">      conditions.add(mapConstructionItem);</span>
<span class="nc" id="L2478">    }</span>

    /**
     * Payload text.
     *
     * @param mappingToken the mapping token
     * @param filter the filter
     */
    private void payloadText(MtasParserMappingToken mappingToken,
        String filter) {
<span class="nc" id="L2488">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2489">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="nc" id="L2490">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_TEXT);</span>
<span class="nc" id="L2491">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="nc" id="L2492">      mappingToken.payload.add(mapConstructionItem);</span>
<span class="nc" id="L2493">    }</span>

    /**
     * Adds the attribute.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param name the name
     * @param prefix the prefix
     * @param filter the filter
     */
    private void addAttribute(MtasParserMappingToken mappingToken, String type,
        String name, String namespace, String prefix, String filter) {
<span class="fc" id="L2506">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2507">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="fc" id="L2508">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L2509">      mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="fc" id="L2510">      mapConstructionItem.put(MAPPING_VALUE_NAMESPACE, namespace);</span>
<span class="fc" id="L2511">      mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="fc" id="L2512">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="pc bpc" id="L2513" title="1 of 2 branches missed.">      if (name != null) {</span>
<span class="fc bfc" id="L2514" title="All 2 branches covered.">        if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="fc" id="L2515">          mappingToken.preValues.add(mapConstructionItem);</span>
<span class="pc bpc" id="L2516" title="1 of 2 branches missed.">        } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="fc" id="L2517">          mappingToken.postValues.add(mapConstructionItem);</span>
        }
      }
<span class="fc" id="L2520">    }</span>

    /**
     * Adds the variable from attribute.
     *
     * @param mappingToken the mapping token
     * @param type the type
     * @param name the name
     * @param prefix the prefix
     * @param value the value
     */
    private void addVariableFromAttribute(MtasParserMappingToken mappingToken,
        String type, String name, String prefix, String value) {
<span class="nc" id="L2533">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2534">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="nc" id="L2535">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_VARIABLE);</span>
<span class="nc" id="L2536">      mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="nc" id="L2537">      mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="nc" id="L2538">      mapConstructionItem.put(MAPPING_VALUE_VALUE, value);</span>
<span class="nc bnc" id="L2539" title="All 4 branches missed.">      if (name != null &amp;&amp; value != null) {</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">        if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="nc" id="L2541">          mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2542" title="All 2 branches missed.">        } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2543">          mappingToken.postValues.add(mapConstructionItem);</span>
        }
      }
<span class="nc" id="L2546">    }</span>

    /**
     * Condition attribute.
     *
     * @param name the name
     * @param condition the condition
     * @param filter the filter
     * @param not the not
     */
    private void conditionAttribute(String name, String namespace, String condition,
        String filter, String not) {
<span class="fc" id="L2558">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2559">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="fc" id="L2560">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L2561">      mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="fc" id="L2562">      mapConstructionItem.put(MAPPING_VALUE_NAMESPACE, namespace);</span>
<span class="fc" id="L2563">      mapConstructionItem.put(MAPPING_VALUE_CONDITION, condition);</span>
<span class="fc" id="L2564">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="fc" id="L2565">      mapConstructionItem.put(MAPPING_VALUE_NOT, not);</span>
<span class="pc bpc" id="L2566" title="1 of 2 branches missed.">      if (name != null) {</span>
<span class="fc" id="L2567">        conditions.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2569">    }</span>

    /**
     * Payload attribute.
     *
     * @param mappingToken the mapping token
     * @param name the name
     * @param filter the filter
     */
    private void payloadAttribute(MtasParserMappingToken mappingToken,
        String name, String filter) {
<span class="fc" id="L2580">      HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2581">      mapConstructionItem.put(MAPPING_VALUE_SOURCE, SOURCE_OWN);</span>
<span class="fc" id="L2582">      mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L2583">      mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="fc" id="L2584">      mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="fc" id="L2585">      mappingToken.payload.add(mapConstructionItem);</span>
<span class="fc" id="L2586">    }</span>

    /**
     * Condition ancestor.
     *
     * @param ancestorType the ancestor type
     * @param number the number
     */
    public void conditionAncestor(String ancestorType, String number) {
<span class="pc bpc" id="L2595" title="1 of 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="pc bpc" id="L2596" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="pc bpc" id="L2599" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2600" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="fc" id="L2601">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2602">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="fc" id="L2603">        mapConstructionItem.put(MAPPING_VALUE_NUMBER, number);</span>
<span class="fc" id="L2604">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_EXISTENCE);</span>
<span class="fc" id="L2605">        conditions.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2607">    }</span>

    /**
     * Adds the ancestor name.
     *
     * @param ancestorType the ancestor type
     * @param mappingToken the mapping token
     * @param type the type
     * @param distance the distance
     * @param prefix the prefix
     * @param filter the filter
     */
    private void addAncestorName(String ancestorType,
        MtasParserMappingToken mappingToken, String type, String distance,
        String prefix, String filter) {
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="pc bpc" id="L2623" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="pc bpc" id="L2624" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="fc bfc" id="L2625" title="All 2 branches covered.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="pc bpc" id="L2626" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="fc" id="L2628">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2629">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="fc" id="L2630">        mapConstructionItem.put(MAPPING_VALUE_ANCESTOR, distance);</span>
<span class="fc" id="L2631">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_NAME);</span>
<span class="fc" id="L2632">        mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="fc" id="L2633">        mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="pc bpc" id="L2634" title="1 of 2 branches missed.">        if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="fc" id="L2635">          mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">        } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2637">          mappingToken.postValues.add(mapConstructionItem);</span>
        }
      }
<span class="fc" id="L2640">    }</span>

    /**
     * Condition ancestor name.
     *
     * @param ancestorType the ancestor type
     * @param distance the distance
     * @param condition the condition
     * @param filter the filter
     * @param not the not
     */
    public void conditionAncestorName(String ancestorType, String distance,
        String condition, String filter, String not) {
<span class="pc bpc" id="L2653" title="1 of 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="fc bfc" id="L2656" title="All 2 branches covered.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="pc bpc" id="L2657" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="fc" id="L2659">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2660">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="fc" id="L2661">        mapConstructionItem.put(MAPPING_VALUE_ANCESTOR, distance);</span>
<span class="fc" id="L2662">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_NAME);</span>
<span class="fc" id="L2663">        mapConstructionItem.put(MAPPING_VALUE_CONDITION, condition);</span>
<span class="fc" id="L2664">        mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="fc" id="L2665">        mapConstructionItem.put(MAPPING_VALUE_NOT, not);</span>
<span class="fc" id="L2666">        conditions.add(mapConstructionItem);</span>
      }
<span class="fc" id="L2668">    }</span>

    /**
     * Adds the ancestor attribute.
     *
     * @param ancestorType the ancestor type
     * @param mappingToken the mapping token
     * @param type the type
     * @param distance the distance
     * @param name the name
     * @param prefix the prefix
     * @param filter the filter
     */
    public void addAncestorAttribute(String ancestorType,
        MtasParserMappingToken mappingToken, String type, String distance,
        String name, String prefix, String filter) {
<span class="nc bnc" id="L2684" title="All 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2690">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2691">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="nc" id="L2692">        mapConstructionItem.put(MAPPING_VALUE_ANCESTOR, distance);</span>
<span class="nc" id="L2693">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="nc" id="L2694">        mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="nc" id="L2695">        mapConstructionItem.put(MAPPING_VALUE_PREFIX, prefix);</span>
<span class="nc" id="L2696">        mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc bnc" id="L2698" title="All 2 branches missed.">          if (type.equals(MAPPING_SUBTYPE_TOKEN_PRE)) {</span>
<span class="nc" id="L2699">            mappingToken.preValues.add(mapConstructionItem);</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">          } else if (type.equals(MAPPING_SUBTYPE_TOKEN_POST)) {</span>
<span class="nc" id="L2701">            mappingToken.postValues.add(mapConstructionItem);</span>
          }
        }
      }
<span class="nc" id="L2705">    }</span>

    /**
     * Condition ancestor attribute.
     *
     * @param ancestorType the ancestor type
     * @param distance the distance
     * @param name the name
     * @param condition the condition
     * @param filter the filter
     * @param not the not
     */
    public void conditionAncestorAttribute(String ancestorType, String distance,
        String name, String condition, String filter, String not) {
<span class="nc bnc" id="L2719" title="All 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="nc bnc" id="L2722" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="nc bnc" id="L2723" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2725">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2726">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="nc" id="L2727">        mapConstructionItem.put(MAPPING_VALUE_ANCESTOR, distance);</span>
<span class="nc" id="L2728">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="nc" id="L2729">        mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="nc" id="L2730">        mapConstructionItem.put(MAPPING_VALUE_CONDITION, condition);</span>
<span class="nc" id="L2731">        mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="nc" id="L2732">        mapConstructionItem.put(MAPPING_VALUE_NOT, not);</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L2734">          conditions.add(mapConstructionItem);</span>
        }
      }
<span class="nc" id="L2737">    }</span>

    /**
     * Payload ancestor attribute.
     *
     * @param mappingToken the mapping token
     * @param ancestorType the ancestor type
     * @param distance the distance
     * @param name the name
     * @param filter the filter
     */
    private void payloadAncestorAttribute(MtasParserMappingToken mappingToken,
        String ancestorType, String distance, String name, String filter) {
<span class="pc bpc" id="L2750" title="1 of 2 branches missed.">      if (ancestorType.equals(SOURCE_ANCESTOR_GROUP)</span>
<span class="pc bpc" id="L2751" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_GROUP_ANNOTATION)</span>
<span class="pc bpc" id="L2752" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD)</span>
<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_WORD_ANNOTATION)</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION)</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">          || ancestorType.equals(SOURCE_ANCESTOR_RELATION_ANNOTATION)) {</span>
<span class="fc" id="L2756">        HashMap&lt;String, String&gt; mapConstructionItem = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2757">        mapConstructionItem.put(MAPPING_VALUE_SOURCE, ancestorType);</span>
<span class="fc" id="L2758">        mapConstructionItem.put(MAPPING_VALUE_ANCESTOR, distance);</span>
<span class="fc" id="L2759">        mapConstructionItem.put(MAPPING_VALUE_TYPE, PARSER_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L2760">        mapConstructionItem.put(MAPPING_VALUE_NAME, name);</span>
<span class="fc" id="L2761">        mapConstructionItem.put(MAPPING_VALUE_FILTER, filter);</span>
<span class="pc bpc" id="L2762" title="1 of 2 branches missed.">        if (name != null) {</span>
<span class="fc" id="L2763">          mappingToken.payload.add(mapConstructionItem);</span>
        }
      }
<span class="fc" id="L2766">    }</span>

    /**
     * Compute ancestor source type.
     *
     * @param type the type
     * @return the string
     * @throws MtasConfigException the mtas config exception
     */
    private String computeAncestorSourceType(String type)
        throws MtasConfigException {
<span class="pc bpc" id="L2777" title="1 of 2 branches missed.">      if (type.equals(MAPPING_TYPE_GROUP)) {</span>
<span class="nc" id="L2778">        return SOURCE_ANCESTOR_GROUP;</span>
<span class="pc bpc" id="L2779" title="1 of 2 branches missed.">      } else if (type.equals(MAPPING_TYPE_GROUP_ANNOTATION)) {</span>
<span class="nc" id="L2780">        return SOURCE_ANCESTOR_GROUP_ANNOTATION;</span>
<span class="pc bpc" id="L2781" title="1 of 2 branches missed.">      } else if (type.equals(MAPPING_TYPE_WORD)) {</span>
<span class="nc" id="L2782">        return SOURCE_ANCESTOR_WORD;</span>
<span class="fc bfc" id="L2783" title="All 2 branches covered.">      } else if (type.equals(MAPPING_TYPE_WORD_ANNOTATION)) {</span>
<span class="fc" id="L2784">        return SOURCE_ANCESTOR_WORD_ANNOTATION;</span>
<span class="pc bpc" id="L2785" title="1 of 2 branches missed.">      } else if (type.equals(MAPPING_TYPE_RELATION)) {</span>
<span class="fc" id="L2786">        return SOURCE_ANCESTOR_RELATION;</span>
<span class="nc bnc" id="L2787" title="All 2 branches missed.">      } else if (type.equals(MAPPING_TYPE_RELATION_ANNOTATION)) {</span>
<span class="nc" id="L2788">        return SOURCE_ANCESTOR_RELATION_ANNOTATION;</span>
      } else {
<span class="nc" id="L2790">        throw new MtasConfigException(&quot;unknown type &quot; + type);</span>
      }
    }

    /**
     * Compute distance.
     *
     * @param distance the distance
     * @return the string
     */
    private String computeDistance(String distance) {
<span class="fc" id="L2801">      Integer i = 0;</span>
<span class="fc bfc" id="L2802" title="All 2 branches covered.">      if (distance != null) {</span>
<span class="fc" id="L2803">        Integer d = Integer.parseInt(distance);</span>
<span class="pc bpc" id="L2804" title="2 of 4 branches missed.">        if ((d != null) &amp;&amp; (d &gt;= i)) {</span>
<span class="fc" id="L2805">          return distance;</span>
        } else {
<span class="nc" id="L2807">          return i.toString();</span>
        }
      }
<span class="fc" id="L2810">      return null;</span>
    }

    /**
     * Compute number.
     *
     * @param number the number
     * @return the string
     */
    private String computeNumber(String number) {
<span class="fc" id="L2820">      return computeDistance(number);</span>
    }

    /**
     * Gets the tokens.
     *
     * @return the tokens
     */
    public List&lt;MtasParserMappingToken&gt; getTokens() {
<span class="fc" id="L2829">      return tokens;</span>
    }

    /**
     * Gets the conditions.
     *
     * @return the conditions
     */
    public List&lt;Map&lt;String, String&gt;&gt; getConditions() {
<span class="fc" id="L2838">      return conditions;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L2848">      StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L2849">      builder.append(&quot;mapping - type:&quot; + type + &quot;, offset:&quot; + offset</span>
          + &quot;, realOffset:&quot; + realOffset + &quot;, position:&quot; + position);
<span class="nc bnc" id="L2851" title="All 2 branches missed.">      for (int i = 0; i &lt; conditions.size(); i++) {</span>
<span class="nc" id="L2852">        builder.append(&quot;\n\tcondition &quot; + i + &quot;: &quot;);</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">        for (Entry&lt;String, String&gt; entry : conditions.get(i).entrySet()) {</span>
<span class="nc" id="L2854">          builder.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;,&quot;);</span>
<span class="nc" id="L2855">        }</span>
      }
<span class="nc bnc" id="L2857" title="All 2 branches missed.">      for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="nc" id="L2858">        builder.append(&quot;\n\ttoken &quot; + i);</span>
<span class="nc" id="L2859">        builder.append(&quot; - &quot; + tokens.get(i).type);</span>
<span class="nc" id="L2860">        builder.append(&quot; [offset:&quot; + tokens.get(i).offset);</span>
<span class="nc" id="L2861">        builder.append(&quot;,realoffset:&quot; + tokens.get(i).realoffset);</span>
<span class="nc" id="L2862">        builder.append(&quot;,parent:&quot; + tokens.get(i).parent + &quot;]&quot;);</span>
<span class="nc bnc" id="L2863" title="All 2 branches missed.">        for (int j = 0; j &lt; tokens.get(i).preValues.size(); j++) {</span>
<span class="nc" id="L2864">          builder.append(&quot;\n\t- pre &quot; + j + &quot;: &quot;);</span>
<span class="nc bnc" id="L2865" title="All 2 branches missed.">          for (Entry&lt;String, String&gt; entry : tokens.get(i).preValues.get(j)</span>
<span class="nc" id="L2866">              .entrySet()) {</span>
<span class="nc" id="L2867">            builder.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;,&quot;);</span>
<span class="nc" id="L2868">          }</span>
        }
<span class="nc bnc" id="L2870" title="All 2 branches missed.">        for (int j = 0; j &lt; tokens.get(i).postValues.size(); j++) {</span>
<span class="nc" id="L2871">          builder.append(&quot;\n\t- post &quot; + j + &quot;: &quot;);</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">          for (Entry&lt;String, String&gt; entry : tokens.get(i).postValues.get(j)</span>
<span class="nc" id="L2873">              .entrySet()) {</span>
<span class="nc" id="L2874">            builder.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;,&quot;);</span>
<span class="nc" id="L2875">          }</span>
        }
<span class="nc bnc" id="L2877" title="All 2 branches missed.">        for (int j = 0; j &lt; tokens.get(i).payload.size(); j++) {</span>
<span class="nc" id="L2878">          builder.append(&quot;\n\t- payload &quot; + j + &quot;: &quot;);</span>
<span class="nc bnc" id="L2879" title="All 2 branches missed.">          for (Entry&lt;String, String&gt; entry : tokens.get(i).payload.get(j)</span>
<span class="nc" id="L2880">              .entrySet()) {</span>
<span class="nc" id="L2881">            builder.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;,&quot;);</span>
<span class="nc" id="L2882">          }</span>
        }
      }
<span class="nc" id="L2885">      return builder.toString();</span>
    }

  }

  /**
   * The Class MtasParserObject.
   */
  protected class MtasParserObject {

    /** The object type. */
    MtasParserType objectType;

    /** The object real offset start. */
<span class="fc" id="L2899">    private Integer objectRealOffsetStart = null;</span>

    /** The object real offset end. */
<span class="fc" id="L2902">    private Integer objectRealOffsetEnd = null;</span>

    /** The object offset start. */
<span class="fc" id="L2905">    private Integer objectOffsetStart = null;</span>

    /** The object offset end. */
<span class="fc" id="L2908">    private Integer objectOffsetEnd = null;</span>

    /** The object text. */
<span class="fc" id="L2911">    private String objectText = null;</span>

    /** The object id. */
<span class="fc" id="L2914">    protected String objectId = null;</span>

    /** The object unknown ancestor number. */
<span class="fc" id="L2917">    private Integer objectUnknownAncestorNumber = null;</span>

    /** The object attributes. */
<span class="fc" id="L2920">    protected HashMap&lt;String, String&gt; objectAttributes = null;</span>

    /** The other object attributes. */
<span class="fc" id="L2923">    protected HashMap&lt;String, HashMap&lt;String, String&gt;&gt; objectOtherAttributes = null;</span>

    /** The object positions. */
<span class="fc" id="L2926">    private SortedSet&lt;Integer&gt; objectPositions = new TreeSet&lt;&gt;();</span>

    /** The ref ids. */
<span class="fc" id="L2929">    private Set&lt;String&gt; refIds = new HashSet&lt;&gt;();</span>

    /** The updateable mappings as parent. */
<span class="fc" id="L2932">    private Set&lt;Integer&gt; updateableMappingsAsParent = new HashSet&lt;&gt;();</span>

    /** The updateable ids with position. */
<span class="fc" id="L2935">    private Set&lt;String&gt; updateableIdsWithPosition = new HashSet&lt;&gt;();</span>

    /** The updateable mappings with position. */
<span class="fc" id="L2938">    protected Set&lt;Integer&gt; updateableMappingsWithPosition = new HashSet&lt;&gt;();</span>

    /** The updateable ids with offset. */
<span class="fc" id="L2941">    private Set&lt;String&gt; updateableIdsWithOffset = new HashSet&lt;&gt;();</span>

    /** The updateable mappings with offset. */
<span class="fc" id="L2944">    protected Set&lt;Integer&gt; updateableMappingsWithOffset = new HashSet&lt;&gt;();</span>

    /** The referred start position. */
<span class="fc" id="L2947">    protected Map&lt;String, Integer&gt; referredStartPosition = new HashMap&lt;&gt;();</span>

    /** The referred end position. */
<span class="fc" id="L2950">    protected Map&lt;String, Integer&gt; referredEndPosition = new HashMap&lt;&gt;();</span>

    /** The referred start offset. */
<span class="fc" id="L2953">    protected Map&lt;String, Integer&gt; referredStartOffset = new HashMap&lt;&gt;();</span>

    /** The referred end offset. */
<span class="fc" id="L2956">    protected Map&lt;String, Integer&gt; referredEndOffset = new HashMap&lt;&gt;();</span>

    /**
     * Instantiates a new mtas parser object.
     *
     * @param type the type
     */
<span class="fc" id="L2963">    MtasParserObject(MtasParserType type) {</span>
<span class="fc" id="L2964">      objectType = type;</span>
<span class="fc" id="L2965">      objectAttributes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2966">      objectOtherAttributes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2967">    }</span>

    /**
     * Register updateable mapping at parent.
     *
     * @param mappingId the mapping id
     */
    public void registerUpdateableMappingAtParent(Integer mappingId) {
<span class="fc" id="L2975">      updateableMappingsAsParent.add(mappingId);</span>
<span class="fc" id="L2976">    }</span>

    /**
     * Register updateable mappings at parent.
     *
     * @param mappingIds the mapping ids
     */
    public void registerUpdateableMappingsAtParent(Set&lt;Integer&gt; mappingIds) {
<span class="fc" id="L2984">      updateableMappingsAsParent.addAll(mappingIds);</span>
<span class="fc" id="L2985">    }</span>

    /**
     * Gets the updateable mappings as parent.
     *
     * @return the updateable mappings as parent
     */
    public Set&lt;Integer&gt; getUpdateableMappingsAsParent() {
<span class="fc" id="L2993">      return updateableMappingsAsParent;</span>
    }

    /**
     * Reset updateable mappings as parent.
     */
    public void resetUpdateableMappingsAsParent() {
<span class="fc" id="L3000">      updateableMappingsAsParent.clear();</span>
<span class="fc" id="L3001">    }</span>

    /**
     * Adds the updateable mapping with position.
     *
     * @param mappingId the mapping id
     */
    public void addUpdateableMappingWithPosition(Integer mappingId) {
<span class="nc" id="L3009">      updateableMappingsWithPosition.add(mappingId);</span>
<span class="nc" id="L3010">    }</span>

    /**
     * Adds the updateable id with offset.
     *
     * @param id the id
     */
    public void addUpdateableIdWithOffset(String id) {
<span class="nc" id="L3018">      updateableIdsWithOffset.add(id);</span>
<span class="nc" id="L3019">    }</span>

    /**
     * Adds the updateable mapping with offset.
     *
     * @param mappingId the mapping id
     */
    public void addUpdateableMappingWithOffset(Integer mappingId) {
<span class="fc" id="L3027">      updateableMappingsWithOffset.add(mappingId);</span>
<span class="fc" id="L3028">    }</span>

    /**
     * Update mappings.
     *
     * @param idPositions the id positions
     * @param idOffsets the id offsets
     */
    public void updateMappings(Map&lt;String, Set&lt;Integer&gt;&gt; idPositions,
        Map&lt;String, Integer[]&gt; idOffsets) {
<span class="pc bpc" id="L3038" title="1 of 2 branches missed.">      for (Integer mappingId : updateableMappingsWithPosition) {</span>
<span class="nc" id="L3039">        tokenCollection.get(mappingId).addPositions(objectPositions);</span>
<span class="nc" id="L3040">      }</span>
<span class="fc bfc" id="L3041" title="All 2 branches covered.">      for (Integer mappingId : updateableMappingsWithOffset) {</span>
<span class="fc" id="L3042">        tokenCollection.get(mappingId).addOffset(objectOffsetStart,</span>
            objectOffsetEnd);
<span class="fc" id="L3044">      }</span>
<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">      for (String id : updateableIdsWithPosition) {</span>
<span class="nc bnc" id="L3046" title="All 2 branches missed.">        if (idPositions.containsKey(id)) {</span>
<span class="nc bnc" id="L3047" title="All 2 branches missed.">          if (idPositions.get(id) == null) {</span>
<span class="nc" id="L3048">            idPositions.put(id, objectPositions);</span>
          } else {
<span class="nc" id="L3050">            idPositions.get(id).addAll(objectPositions);</span>
          }
        }
<span class="nc" id="L3053">      }</span>
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">      for (String id : updateableIdsWithOffset) {</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">        if (idOffsets.containsKey(id)) {</span>
<span class="nc" id="L3056">          Integer[] currentOffset = idOffsets.get(id);</span>
<span class="nc bnc" id="L3057" title="All 4 branches missed.">          if (currentOffset == null || currentOffset.length == 0) {</span>
<span class="nc" id="L3058">            idOffsets.put(id,</span>
                new Integer[] { objectOffsetStart, objectOffsetEnd });
          }
        }
<span class="nc" id="L3062">      }</span>
<span class="fc" id="L3063">    }</span>

    /**
     * Gets the attribute.
     *
     * @param name the name
     * @return the attribute
     */
    public String getAttribute(String name) {
<span class="pc bpc" id="L3072" title="1 of 2 branches missed.">      if (name != null) {</span>
<span class="fc" id="L3073">        return objectAttributes.get(name);</span>
      } else {
<span class="nc" id="L3075">        return null;</span>
      }
    }
    
    public String getOtherAttribute(String other, String name) {
<span class="nc bnc" id="L3080" title="All 2 branches missed.">      if(other==null) {</span>
<span class="nc" id="L3081">        return getAttribute(name);</span>
      } else {
<span class="nc bnc" id="L3083" title="All 2 branches missed.">        if(objectOtherAttributes.containsKey(other)) {</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">          if (name != null) {</span>
<span class="nc" id="L3085">            return objectOtherAttributes.get(other).get(name);</span>
          } else {
<span class="nc" id="L3087">            return null;</span>
          }
        } else {
<span class="nc" id="L3090">          return null;</span>
        }        
      }  
    }

    /**
     * Gets the id.
     *
     * @return the id
     */
    public String getId() {
<span class="fc" id="L3101">      return objectId;</span>
    }

    /**
     * Gets the type.
     *
     * @return the type
     */
    MtasParserType getType() {
<span class="fc" id="L3110">      return objectType;</span>
    }

    /**
     * Sets the text.
     *
     * @param text the new text
     */
    public void setText(String text) {
<span class="nc" id="L3119">      objectText = text;</span>
<span class="nc" id="L3120">    }</span>

    /**
     * Adds the text.
     *
     * @param text the text
     */
    public void addText(String text) {
<span class="fc bfc" id="L3128" title="All 2 branches covered.">      if (objectText == null) {</span>
<span class="fc" id="L3129">        objectText = text;</span>
      } else {
<span class="fc" id="L3131">        objectText += text;</span>
      }
<span class="fc" id="L3133">    }</span>

    /**
     * Gets the text.
     *
     * @return the text
     */
    public String getText() {
<span class="fc" id="L3141">      return objectText;</span>
    }

    /**
     * Sets the unknown ancestor number.
     *
     * @param i the new unknown ancestor number
     */
    public void setUnknownAncestorNumber(Integer i) {
<span class="fc" id="L3150">      objectUnknownAncestorNumber = i;</span>
<span class="fc" id="L3151">    }</span>

    /**
     * Gets the unknown ancestor number.
     *
     * @return the unknown ancestor number
     */
    public Integer getUnknownAncestorNumber() {
<span class="fc" id="L3159">      return objectUnknownAncestorNumber;</span>
    }

    /**
     * Sets the real offset start.
     *
     * @param start the new real offset start
     */
    public void setRealOffsetStart(Integer start) {
<span class="fc" id="L3168">      objectRealOffsetStart = start;</span>
<span class="fc" id="L3169">    }</span>

    /**
     * Gets the real offset start.
     *
     * @return the real offset start
     */
    public Integer getRealOffsetStart() {
<span class="fc" id="L3177">      return objectRealOffsetStart;</span>
    }

    /**
     * Sets the real offset end.
     *
     * @param end the new real offset end
     */
    public void setRealOffsetEnd(Integer end) {
<span class="fc" id="L3186">      objectRealOffsetEnd = end;</span>
<span class="fc" id="L3187">    }</span>

    /**
     * Gets the real offset end.
     *
     * @return the real offset end
     */
    public Integer getRealOffsetEnd() {
<span class="fc" id="L3195">      return objectRealOffsetEnd;</span>
    }

    /**
     * Sets the offset start.
     *
     * @param start the new offset start
     */
    public void setOffsetStart(Integer start) {
<span class="fc" id="L3204">      objectOffsetStart = start;</span>
<span class="fc" id="L3205">    }</span>

    /**
     * Adds the offset start.
     *
     * @param start the start
     */
    public void addOffsetStart(Integer start) {
<span class="pc bpc" id="L3213" title="1 of 4 branches missed.">      if ((start != null)</span>
<span class="pc bpc" id="L3214" title="1 of 2 branches missed.">          &amp;&amp; ((objectOffsetStart == null) || (start &lt; objectOffsetStart))) {</span>
<span class="fc" id="L3215">        objectOffsetStart = start;</span>
      }
<span class="fc" id="L3217">    }</span>

    /**
     * Adds the offset end.
     *
     * @param end the end
     */
    public void addOffsetEnd(Integer end) {
<span class="pc bpc" id="L3225" title="1 of 4 branches missed.">      if ((end != null)</span>
<span class="pc bpc" id="L3226" title="1 of 2 branches missed.">          &amp;&amp; ((objectOffsetEnd == null) || (end &gt; objectOffsetEnd))) {</span>
<span class="fc" id="L3227">        objectOffsetEnd = end;</span>
      }
<span class="fc" id="L3229">    }</span>

    /**
     * Gets the offset start.
     *
     * @return the offset start
     */
    public Integer getOffsetStart() {
<span class="fc" id="L3237">      return objectOffsetStart;</span>
    }

    /**
     * Sets the offset end.
     *
     * @param end the new offset end
     */
    public void setOffsetEnd(Integer end) {
<span class="fc" id="L3246">      objectOffsetEnd = end;</span>
<span class="fc" id="L3247">    }</span>

    /**
     * Gets the offset end.
     *
     * @return the offset end
     */
    public Integer getOffsetEnd() {
<span class="fc" id="L3255">      return objectOffsetEnd;</span>
    }

    /**
     * Gets the offset.
     *
     * @return the offset
     */
    public Integer[] getOffset() {
<span class="fc bfc" id="L3264" title="All 2 branches covered.">      if (objectOffsetStart != null) {</span>
<span class="fc" id="L3265">        return new Integer[] { objectOffsetStart, objectOffsetEnd };</span>
      } else {
<span class="fc" id="L3267">        return new Integer[0];</span>
      }
    }

    /**
     * Adds the position.
     *
     * @param position the position
     */
    public void addPosition(Integer position) {
<span class="fc" id="L3277">      objectPositions.add(position);</span>
<span class="fc" id="L3278">    }</span>

    /**
     * Adds the positions.
     *
     * @param positions the positions
     */
    public void addPositions(Set&lt;Integer&gt; positions) {
<span class="fc" id="L3286">      objectPositions.addAll(positions);</span>
<span class="fc" id="L3287">    }</span>

    /**
     * Gets the positions.
     *
     * @return the positions
     */
    public SortedSet&lt;Integer&gt; getPositions() {
<span class="fc" id="L3295">      return objectPositions;</span>
    }

    /**
     * Adds the ref id.
     *
     * @param id the id
     */
    public void addRefId(String id) {
<span class="pc bpc" id="L3304" title="1 of 2 branches missed.">      if (id != null) {</span>
<span class="fc" id="L3305">        refIds.add(id);</span>
      }
<span class="fc" id="L3307">    }</span>

    /**
     * Gets the ref ids.
     *
     * @return the ref ids
     */
    public Set&lt;String&gt; getRefIds() {
<span class="fc" id="L3315">      return refIds;</span>
    }

    /**
     * Sets the referred start position.
     *
     * @param id the id
     * @param position the position
     */
    public void setReferredStartPosition(String id, Integer position) {
<span class="nc" id="L3325">      referredStartPosition.put(id, position);</span>
<span class="nc" id="L3326">    }</span>

    /**
     * Sets the referred end position.
     *
     * @param id the id
     * @param position the position
     */
    public void setReferredEndPosition(String id, Integer position) {
<span class="nc" id="L3335">      referredEndPosition.put(id, position);</span>
<span class="nc" id="L3336">    }</span>

    /**
     * Sets the referred start offset.
     *
     * @param id the id
     * @param offset the offset
     */
    public void setReferredStartOffset(String id, Integer offset) {
<span class="nc" id="L3345">      referredStartOffset.put(id, offset);</span>
<span class="nc" id="L3346">    }</span>

    /**
     * Sets the referred end offset.
     *
     * @param id the id
     * @param offset the offset
     */
    public void setReferredEndOffset(String id, Integer offset) {
<span class="nc" id="L3355">      referredEndOffset.put(id, offset);</span>
<span class="nc" id="L3356">    }</span>

    /**
     * Clear referred.
     */
    public void clearReferred() {
<span class="nc" id="L3362">      referredStartPosition.clear();</span>
<span class="nc" id="L3363">      referredEndPosition.clear();</span>
<span class="nc" id="L3364">      referredStartOffset.clear();</span>
<span class="nc" id="L3365">      referredEndOffset.clear();</span>
<span class="nc" id="L3366">    }</span>

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>